\documentclass[a4paper]{article}
\usepackage[a4paper,showframe=false]{geometry}
\usepackage{multicol}
\usepackage{amsmath}
\usepackage{mathpartir}
\usepackage{hyperref}
\usepackage{todonotes}
\usepackage{kpfonts}
\usepackage{array}
\usepackage{changepage}
\usepackage[T1]{fontenc}

\newcolumntype{L}{>{$}l<{$}}

% notations
\newcommand*{\defined}{\triangleq}
\newcommand*{\maps}{\rightarrow}
\newcommand*{\derived}{::=}
\newcommand*{\sem}[1]{\llbracket {#1} \rrbracket}


% definitions
\newcommand*{\CONF}{\text{ExecConf}}
\newcommand*{\STATE}{\text{State}}
\newcommand*{\MEM}{\text{GlobalMem}}
\newcommand*{\SSS}{\text{ShareStates}}
\newcommand*{\PID}{\text{PID}}
\newcommand*{\REGS}{\text{Registers}}
\newcommand*{\ADDR}{\text{Address}}
\newcommand*{\WORD}{\text{Word}}
\newcommand*{\VMID}{\text{VMID}}
\newcommand*{\REGNAMES}{\text{RegisterName}}
\newcommand*{\MODE}{\text{ExecMode}}
\newcommand*{\DONE}{\text{DoneState}}
\newcommand*{\INSTR}{\text{Instruction}}

% parameters
\newcommand*{\PABITS}{\text{ADDR\_BITS}}
\newcommand*{\PPBITS}{\text{PAGE\_BITS}}
\newcommand*{\PPIDBITS}{\text{PID\_BITS}}
\newcommand*{\PAMAX}{\text{ADDR\_MAX}}
\newcommand*{\PPMAX}{\text{PAGE\_MAX}}
\newcommand*{\PPIDMAX}{\text{PID\_MAX}}
\newcommand*{\PWBITS}{\text{WORD\_BITS}}
\newcommand*{\PWMAX}{\text{WORD\_MAX}}
\newcommand*{\PVMMAX}{\text{VM\_MAX}}


% instructions
\newcommand*{\instrm}[1]{\mathtt{#1}}
\newcommand*{\instr}[1]{\texttt{#1}}

% TODO: message passing instructions

% expressions
\newcommand*{\EI}[1]{\mathtt{ExecInstr} \; {#1}}
\newcommand*{\RP}[1]{\mathtt{Repeat} \; {#1}}
\newcommand*{\DN}[1]{\mathtt{Done} \; {#1}}
\newcommand*{\NXT}[1]{\mathtt{Next} \; {#1}}

% functions
\newcommand*{\decode}{\text{decode}}
\newcommand*{\valida}{\text{valida}}
\newcommand*{\updpc}{\text{updpc}}
\newcommand*{\pid}{\text{pid}}


% reference
\renewcommand{\DefTirName}[1]{\hypertarget{#1}{\TirName {#1}}}
\newcommand{\refr}[1]{\hyperlink{#1}{\TirName {#1}}}

% SOME/NONE
\newcommand{\SOME}{\mathtt{Some}}
\newcommand{\NONE}{\mathtt{None}}

\title{Operational Semantics % and Proof Rules
  for VMs in Hafnium} \date{\today}
\author{Zongyuan Liu}

\begin{document}
\maketitle

\section{Operational Semantics}

\todo{later: more realistic scheduling}
\subsection{Settings of Hafnium}
Hafnium is a type-1 hypervisor running on the AArch64 architecture(for now),
which is claimed can provide memory isolation between a set of virtual
machines(VMs) running on it. Hafnium provides memory isolation by managing the
stage-2 page tables of VMs. It controls the stage-2 translation by manipulating
entries in stage-2 page tables only according to the FF-A calls issued by VMs.
The hardware does the actual address translation by looking up page table
entries, which we assume acting correctly as described. Therefore Hafnium can
guarantee that one VM can never access to the memory owned by another VM without
that VM's consent.

For the sake of simplicity, stage-2 page tables managed by the Hafnium are
simply one-to-one mappings, i.e. the IPAs are always equal to PAs. Besides, it
is also the case for the stage-1 page table of the Hafnium itself.

FF-A framework are designed as a protocol for components running on the ARM-A
processor, the main purpose of which is to allow components in the normal world
to communicate with components in the secure world. While in Hafnium, VMs and
the hypervisor are all counted as components residing in the normal world. The
FF-A framework serves as an approach for VMs to do message passing and
memory sharing with each other. We will see some examples of how exactly the
FF-A framework is utilized in Hafnium later.

One can read more details on the Hafnium architecture
\href{https://review.trustedfirmware.org/plugins/gitiles/hafnium/hafnium/+/HEAD/docs/Architecture.md}{here}.

\subsection{Execution Configuration}
\todo{later: improve error handling} The general purpose of the operational
semantics is to reason about programs written in assembly language running on
VMs. Therefore, in our operational semantics, we abstract away the Hafnium
hypervisor, considering the whole system only consists of several virtual
machines plus some additional information for the FF-A framework.

\begin{figure}
  \begin{align*}
    \phi &\in \CONF &\defined &list(\STATE) \times \MEM \times \SSS \\
    \delta &\in \STATE &\defined &list(\PID) \times \REGS \times option(\PID \times \PID) \\
    p & \in \PID &\defined  &[ 0, \PPIDMAX ] \\
    r & \in \REGS &\defined  &\REGNAMES \maps \WORD \\
    n & \in \REGNAMES &\derived  &\mathtt{pc} | \mathtt{NZ} | \mathtt {r_{0}} | \mathtt{r_{1}} | \dots \\
    m & \in \MEM &\defined  &\ADDR \maps \WORD \\
    a & \in \ADDR &\defined  &[ 0, \PAMAX ] \\
    w & \in \WORD &\defined  &[ 0, \PWMAX ] \\
    s & \in \SSS &\defined  &list(\PID \times \VMID) \\
    v & \in \VMID &\defined  &[ 0, \PVMMAX ]
  \end{align*}
  \caption{Execution Configuration: VM States, Global Memory and Share States.}
\end{figure}
Figure 1 shows the definition of execution configuration, which includes three
components: $\STATE$s of all VMs, a $\MEM$ shared with all VMs, and a $\SSS$
storing necessary information for memory sharing FF-A requests.

In general, the state of a machine represents values of all
registers of that machine plus values of memory at all locations. In our case,
we have multiple machines. A naive approach to write down the state of all VMs
is to record their states respectively. We only apply it to registers and
combine their memory together as a global memory. The global here means one VM
could be able to access memory of another VM(in the case of memory sharing).

The definition of $\MEM$ is straightforward. While the $\STATE$ consists of not
only registers, but also some $\PID$s. The list of $\PID$ notes $\PID$s of all
pages that one VM owns, which is in principle determined by the stage-2 page
table of that VM.

Page tables essentially are mappings. However, we instead use a mathematical
set($list$ in Figure 1) of $\PID$ to describe the abstract page table of a VM. We
argue that it is sufficient to record the necessary information on the actual page
table. Because in Hafnium, the $\PID$ in IP address space is always equal to the
corresponding one in the physical address space. Namely, we always have mappings
like $x \mapsto x$ in stage-2 page tables. Another benefit of this mapping scheme is
that we can omit stage-2 translation entirely.

One may notice that there are two special $\PID$s that are not included in the
list. They are considered as RX/TX buffers for message passing. The size of
those two buffers is exactly one page, which is consistent to the
implementation of Hafnium. The reason that they are embraced by an $option$ is
that the two pages are uninitialized. There is a FF-A call through which a VM
can assign two pages it owns as its RX and TX pages. Afterwards, the RX/TX pages
are not strictly possessed by the VM anymore. In addition, VM is no longer able to
reassign other pages as RX/TX pages, i.e. RX/TX pages of a VM can only be
configured once.

It is worth to note that the $\mathtt{NZ}$ is a system register, which means one
is only able to access to this register if it is at a high enough Exception
Level. This register is crucial to comparing and jumping instructions. It has
similar functionality as the
\href{https://developer.arm.com/docs/ddi0595/h/aarch64-system-registers/nzcv}
{$\mathtt{NZCV}$ register} in real Arm-A processors.

To explain why we defined the $\SSS$, we need to elaborate on how memory sharing is
specified in the FF-A framework, which we won't do until Section 1.5 when we
show semantics of instructions. For now, it is enough for readers to know that $\PID$ is
the page to share, $\VMID$ the receiver of the sharing, and both are essential
to perform memory sharing. In Hafnium implementation, there is a similar but
much more complicated data structure to record those information(and more),
which is maintained by the Hafnium itself. Since we don't have the hypervisor in
our model, we added $\SSS$ into the execution configuration.

Some constants are introduced to specify basic configurations of the model. In
the context of AArch64, $\PAMAX$ should be $2^{\PABITS} - 1$ where
$\PABITS = 48$, $\PWMAX = 2^{\PWBITS} -1$ where $\PWBITS = 64$, and
$\PPIDMAX = 2^{\PPIDBITS}-1$ where $\PPIDBITS = \PABITS - \PPBITS = 36$.
$\PVMMAX$ makes sure we only have finite number of VMs.


\subsection{Syntax and Instructions}
\begin{figure}[h!]
  \begin{align*}
    \mu &\in \MODE &\derived & \mathtt{ExecInstr} \; v | \mathtt{Repeat} \; \mu | \mathtt{Done} \; \theta \\
    \theta &\in \DONE &\derived & \NXT{v} | \mathtt{Halt} | \mathtt{Fail}\\
    \\
    instr & \in  \INSTR &\derived & \instrm{br} \; r |\instrm{bne} \; r \; r |
                                    \instrm{mov} \; r \; w | \instrm{ldr} \; r\; r|
                                    \instrm{str} \; r \; r | \instrm{add} \; r \; r \; r |
                                    \instrm{sub} \; r \; r \; r | \instrm{cmp} \; r \; r \\
        & & & | \instrm{fail} | \instrm{halt} | \instrm{memd} \; r \; r | \instrm{memr} \; r\; r
  \end{align*}
  \caption{Syntax and Machine Instructions}
\end{figure}
\todo{later: add message passing instructions}

The syntax and instructions included in our model are shown in Figure 2. The
syntax of the expression is uncomplicated. Generally speaking, $\EI{v}$ is for
executing a single instruction in VM $v$ and $\DN{\theta}$ implies the result of
the execution. The result could be successful or failed. In case of success, we
either proceed on the next instruction in VM $v$ with $\NXT{v}$ or halt.

There are two major reasons why we didn't use instructions as expressions. On
one hand,
instructions are related to the execution configuration, their encodings are
stored in the memory. However, we want something independent of the
configuration as expressions so that we can write down the rules in a more
elegant way. On the other hand, $\mathtt{Repeat}$ acts like a context.
Therefore it is more straightforward and natural to come up with the bind rule
in the program logic, comparing to a sequence of instructions.


We included a subset of AArch64 instructions and believe that these instructions
are sufficient to construct interesting programs. Besides, it would be
effortless to include new instructions. All we need to do is adding the
instruction and giving a semantic interpretation. One minor thing to mention is
that we assume addresses in instructions are IPAs, i.e. they have undergone
stage 1 translation.

\subsubsection{Other Instructions}
Other than regular AArch64 instructions, we introduced several new instructions
for message passing and memory sharing. In reality, all sorts of communications
between VMs are indirect in Hafnium system(done through FF-A function calls).
Namely, the hypervisor involves in them. For instance, for memory donation, page
tables need to be modified while only the hypervisor has enough high Exception
Level and access to the memory where page tables reside. The instruction
\texttt{hvc} would be executed with some arguments by the VM to raise the
Exception Level and invoke the hypervisor to do the actual work. It more or less
acts like a system call in OS. However, since our program language for VMs is
assembly and the implementations of FF-A functions are written in C, we choose
not to implement FF-A functions in assembly language but introduce new
instructions with appropriate semantics describing what these functions do.
There are currently two instructions for memory sharing, among that
\texttt{memd} is for donating a page, and \texttt{memr} is for retrieving a
page. We will talk about their semantics later.



\todo{later:initial state?}

\subsection{Reduction rules}
\subsubsection{Notations}
Except claiming explicitly, triple $(\Delta, m, s)$ represents an execution
configuration $\phi$, where $\Delta$ is a list of $\STATE$. $\Delta[i]$ is used
to notate the $\STATE$ of VM $i$ in $\Delta$. Furthermore, we utilize the field
access notation to indicate the list of $\PID$ as $\Delta[i].ps$ and $\REGS$ as
$\Delta[i].rs$ respectively. We overload the square bracket notation to access
the value of a given key in $\REGS$ and $\MEM$ mappings. Occasionally, we
consider lists as sets and apply $\in, \cup,$ and $\setminus$ operators on them.
%,while remaining semantics the same since we barely use the order part of the list.

% In addition, mappings are treated as functions so that they have concepts of
% domain and codomain.

\subsubsection{Rules}


\begin{figure}[h!]
  \begin{mathpar}
    \inferrule[RepeatExec] {(\EI{v},\, \phi) \rightarrow (\DN{\theta} ,\,
      \phi')} {(\RP{\EI{v}} ,\, \phi) \rightarrow (\RP{\DN{\theta}} ,\, \phi')}
    \and \inferrule[RepeatHalt/Fail] {\theta = \mathtt{Halt} \lor \theta =
      \mathtt{Fail}} {(\RP{\DN{\theta}} ,\, \phi) \rightarrow (\DN{\theta} ,\,
      \phi)} \and \inferrule[RepeatNext]{} {(\RP{\DN{\NXT{v}}} ,\, \phi)
      \rightarrow (\RP{\EI{v}} ,\, \phi)} \and \inferrule[ExecInstr]{}
    {{(\EI{v},\, \phi) \rightarrow \left\{
          \begin{array}{ll}
            \sem{\decode(iw)}(\phi,v)
            & \mathrm{if} \;\SOME(ia) = \valida(\Delta[v], \mathtt{pc}) \land m[ia]=iw \\
            (\DN{\mathtt{Fail}},\, \phi) & \mathrm{otherwise}
          \end{array} \right.}
    }
    \and
    \begin{aligned}
      \valida(\delta,r) &=\left\{ \begin{array}{ll}
                                    \SOME(ia) & \text{if} \; ia = \delta.rs[r] \land \pid(ia) \in \delta.ps \\
                                    \NONE & \text{otherwise}
                                  \end{array}
                                \right. \\
      \pid(a) &= a >> \PPBITS
    \end{aligned}
  \end{mathpar}
  \caption{Reduction Steps.}
  % \vspace{-0.5cm}
\end{figure}

The \refr{RepeatExec} rule combined with the \refr{RepeatNext} and
\refr{RepeatHalt/Fail} rules are applied to proceed with the execution.

In \refr{ExecInstr}, the input of the $\decode$ function is a $\WORD$ $iw$
obtained from $\MEM$. $\decode$ function decodes it to the corresponding
$\INSTR$ which has a predefined semantic interpretation. Applying the
interpretation to execution configuration $\phi$ and $\VMID$ v will give us a
new configuration after executing the instruction on VM $v$. If $iw$ is an
invalid encoding, we decode it to $\mathtt{fail}$.

To obtain the encoding of the next executing instruction $iw$, we first get the
value of the \texttt{pc} register of VM $v$ as $ia$, which is the address of the
$iw$ in the global memory. Before decoding $iw$, we have to ensure that the
memory access is valid, i.e. $ia$ is in the range of a page owned by $v$.
The validation is done by $\valida$.


\subsection{Semantic Interpretations of Instructions}

The last piece of the puzzle of operational semantic
is the semantic interpretations of instructions describing how to proceed on
execution, which is shown in Figure 4.

\subsubsection{Notations}
Regarding the modification of the $\STATE$, we use for instance $\Delta'$ to
implies it is modified, distinguishing from the original $\Delta$. Excepting
what we state explicitly, the rest components of $\Delta'$ are identical to the
counterparts in $\Delta$. Informally, one can understand it as we first make a
copy of the $\Delta$ as $\Delta'$, then do some minor modifications on
$\Delta'$.

Note that we only use $\mathtt{mathtt}$ font to represent actual registers.
While the regular \emph{Italic} font is used for any general registers. For
instance, $r_{1}$ doesn't have to be the $\mathtt{r_{1}}$ register.


\newcommand{\sema}[1]{\sem{ {#1} }(\phi,v)}
\newcommand{\leftshift}{\!\!\!\!}
\newcommand{\DNXT}[2]{(\DN{\NXT{ {#1} }}, \updpc( {#2} , {#1} ))\:)} \newcommand{\nextt}{\text{next}}
\begin{figure}[h!]
  \begin{adjustwidth}{-1cm}{}
    \begin{tabular}[t]{L|L L| L}
      \text{Instr}(i) & \sema{i} & \text{where} & \text{Conditions} \\ \hline \hline
      \instrm{fail}& \leftshift  (\DN{\mathtt{Fail}}, \phi) & & \\ \hline
      \instrm{halt}&\leftshift   (\DN{\mathtt{Halt}}, \phi)  & & \\\hline
      \instrm{br} \; r  &\leftshift  (\DN{\NXT{v}},(\Delta',m,s)\:)  & \Delta'[v].rs[\mathtt{pc}]=\Delta[v].rs[r]  &  \\\hline
      \instrm{bne} \; r  & \leftshift  (\DN{\NXT{v}}, (\Delta',m,s)\:)  & \leftshift \begin{array}{l} \Delta'[v].rs[\mathtt{pc}]= \\ \;\;\;\;\left\{
                                \!\!\!\!\begin{array}{ll} \Delta[v].rs[r] &\!\!\!\! \text{if} \;   \Delta[v].rs[\mathtt{NZ}].z=1 \\
                                \Delta[v].rs[\mathtt{pc}]+1 &\!\!\!\! \text{otherwise}
                                        \end{array}\right. \end{array} &  \\\hline
      \instrm{mov}\; r\; w  &\leftshift \nextt(v)(\Delta', m, s)  & \Delta'[v].rs[r]=w & \\\hline
      \instrm{ldr}\; r_{1} \; r_{2}  &\leftshift \nextt(v)(\Delta', m, s) & \Delta'[v].rs[r_{1}]=m[a]  &
                                \SOME(a)=\valida(\Delta[v],r_{2}) \\\hline
      \instrm{str}\; r_{1} \; r_{2}  &\leftshift\nextt(v)(\Delta', m, s)& m'[a]=\Delta[v].rs[r_{2}]&
                                \SOME(a) =\valida(\Delta[v],r_{1}) \\\hline
      \instrm{add}\; r_{1}\; r_{2}\; r_{3} &\leftshift\nextt(v)(\Delta', m, s) &\leftshift \begin{array}{l}\Delta'[v].rs[r_{1}]=\\  \Delta[v].rs[r_{2}] + \Delta[v].rs[r_{3}] \end{array} & \\\hline
      \instrm{sub}\; r_{1}\; r_{2}\; r_{3} &\leftshift\nextt(v)(\Delta', m, s) &\leftshift \begin{array}{l}\Delta'[v].rs[r_{1}]= \\ \Delta[v].rs[r_{2}] - \Delta[v].rs[r_{3}] \end{array} & \\\hline
      \instrm{cmp}\; r_{1}\; r_{2} &\leftshift \nextt(v)(\Delta', m, s)
                                 &\leftshift \begin{array}{l}
                                               w = \Delta[v].rs[r_{1}] - \Delta[v].rs[r_{2}]\\
                                               \Delta'[v].rs[\mathtt{NZ}].z= \\
                                               \;\;\;\left\{ \!\!\!\! \begin{array}{ll} 1 &\text{if}\; w = 0 \\
                                                                        0 & \text{otherwise} \end{array} \right.\\
                                               \Delta'[v].rs[\mathtt{NZ}].n= \\
                                               \;\;\;\left\{\!\!\!\!\begin{array}{ll} 1 &\text{if}\; w < 0 \\
                                                                      0 & \text{otherwise} \end{array} \right.
                                             \end{array}&\\\hline
      \instrm{memd}\; r_{1}\; r_{2} &\leftshift \nextt(v)(\Delta', m, s')
                                 &\!\!\!\!\! \begin{array}{l}
                                               h= \text{len}(s) \\
                                               \Delta'[v].ps=\Delta[v].ps \setminus \{\pid(pa)\}  \\
                                               \Delta'[v].rs[\mathtt{r_{0}}]=h\\
                                               s'[h]=(\pid(pa), \Delta[v].rs[r_{2}])
                                             \end{array}
                      &\leftshift\begin{array}{l}
                                   \SOME(pa)=\valida(\Delta[v],r_{1}) \\
                                   \land v \neq \Delta[v].rs[r_{2}]
                                 \end{array}\\\hline
      \instrm{memr}\; r &\leftshift \nextt(v)(\Delta', m, s')
                                 &\!\!\!\!\! \begin{array}{l}
                                               \Delta'[v].ps=\Delta[v].ps \cup \{p\}\\
                                               s'= s \setminus \{(p,v)\}
                                             \end{array}
                      &\leftshift\begin{array}{l}
                                   s[\Delta[v].rs[r_{1}]] = (p, v)\\
                                   \land p \notin \Delta[v].ps
                                 \end{array} \\\hline
    \end{tabular}
  \end{adjustwidth}
  \begin{align*}
    \updpc((\Delta,m,s),v)&=(\Delta',m,s)\ \; \text{where}\; \Delta'[v].rs[\mathtt{pc}] = \Delta[v].rs[\mathtt{pc}]+1\\
    \nextt(v,\phi) &= \DNXT{v}{\phi}
  \end{align*}
  \caption{Instruction Semantics.}
\end{figure}
\todo{later: consider overflow}

\subsubsection{Semantic Interpretations}
The semantics interpretations of instructions from AArch64 instruction set are generally
trivial. The only worth-mentioned point is the conditions of \instr{ldr} and
\instr{str}. The validity of the target memory accessing address has to be
checked to guarantee the memory isolation property.

As mentioned in Section 1.3, we introduced two newly invented instructions for
memory sharing between VMs. The $\instr{memd}\; r_{1}\; r_{2}$ is executed by
the donor(Sender) to donate a page with $\PID$ stored in the first register to
the recipient(Receiver) whose $\VMID$ is stored in the second register. However,
\instr{memd} merely does half of the donation. According to the specification of
the FF-A framework, it mainly does three things: 1. doing tons of checking; 2.
removing the $\PID$ of the donated page from sender's page table and 3. keeping
donation details in the hypervisor(in $\SSS$) and returning a handle(an index).
If one reads the semantic interpretation of \instr{memd}, he will find out that
it follows the specification, accomplishing the three things totally as well,
just much simpler(so as our configuration). The second half of the donation is
completed by the receiver with \instr{memr}. Hypervisor reads the information of
the donation through the handle passed by the receiver, then it does more
checking and adds the $\PID$ of the donated page into the page table of the
receiver. The difference between the implementation and our simplified
instruction is that we remove the donation information from $\SSS$ while it is
kept and has further usages in the implementation.

%\section{Proof Rules}





\end{document}
