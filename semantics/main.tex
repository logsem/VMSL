\documentclass[a4paper]{article}
\usepackage[a4paper,tmargin=0.75in,bmargin=1in,showframe=false]{geometry}
\usepackage{multicol,multirow}
\usepackage{amsmath}
\usepackage{mathpartir}
\usepackage{hyperref}
\usepackage{todonotes}
\usepackage{graphicx}
\usepackage{kpfonts}
\usepackage{array}
\usepackage{changepage}
\usepackage[T1]{fontenc}
\usepackage{tikz}

\usetikzlibrary{arrows,positioning,fit,shapes}

\newcolumntype{L}{>{$}l<{$}}

% notations
\newcommand*{\defined}{\triangleq}
\newcommand*{\maps}{\rightarrow}
\newcommand*{\derived}{::=}
\newcommand*{\sem}[1]{\llbracket {#1} \rrbracket}
\newcommand*{\append}{\scalebox{0.8}{+\kern-0.4ex+}}


% definitions
\newcommand*{\CONF}{\text{ExecConf}}
\newcommand*{\STATE}{\text{State}}
\newcommand*{\MEM}{\text{GlobalMem}}
\newcommand*{\SSS}{\text{ShareStates}}
\newcommand*{\PID}{\text{PID}}
\newcommand*{\REGS}{\text{Registers}}
\newcommand*{\ADDR}{\text{Address}}
\newcommand*{\WORD}{\text{Word}}
\newcommand*{\VMID}{\text{VMID}}
\newcommand*{\REGNAMES}{\text{RegisterName}}
\newcommand*{\MODE}{\text{ExecMode}}
\newcommand*{\DONE}{\text{DoneState}}
\newcommand*{\INSTR}{\text{Instruction}}
\newcommand*{\MB}{\text{MailBox}}

% parameters
\newcommand*{\PABITS}{\text{ADDR\_BITS}}
\newcommand*{\PPBITS}{\text{PAGE\_BITS}}
\newcommand*{\PPIDBITS}{\text{PID\_BITS}}
\newcommand*{\PAMAX}{\text{ADDR\_MAX}}
\newcommand*{\PPMAX}{\text{PAGE\_MAX}}
\newcommand*{\PPIDMAX}{\text{PID\_MAX}}
\newcommand*{\PWBITS}{\text{WORD\_BITS}}
\newcommand*{\PWMAX}{\text{WORD\_MAX}}
\newcommand*{\PVMMAX}{\text{VM\_MAX}}

% FFA functions
\newcommand*{\INT}{\text{INTERRUPT}}
\newcommand*{\MSGS}{\text{MSG\_SEND}}
\newcommand*{\MSGW}{\text{MSG\_WAIT}}
\newcommand*{\YIELD}{\text{YIELD}}
\newcommand*{\BUSY}{\text{BUSY}}
\newcommand*{\SUCC}{\text{SUCCESS}}
% instructions
\newcommand*{\instrm}[1]{\mathtt{#1}}
\newcommand*{\instr}[1]{\texttt{#1}}

% TODO: message passing instructions

% expressions
\newcommand*{\EI}[1]{\mathtt{ExecInstr} \; {#1}}
\newcommand*{\RP}[1]{\mathtt{Repeat} \; {#1}}
\newcommand*{\DN}[1]{\mathtt{Done} \; {#1}}
\newcommand*{\NXT}[1]{\mathtt{Next} \; {#1}}

% functions
\newcommand*{\decode}{\text{decode}}
\newcommand*{\valida}{\text{valida}}
\newcommand*{\updpc}{\text{updpc}}
\newcommand*{\pid}{\text{pid}}


% reference
\renewcommand{\DefTirName}[1]{\hypertarget{#1}{\TirName {#1}}}
\newcommand{\refr}[1]{\hyperlink{#1}{\TirName {#1}}}

% SOME/NONE
\newcommand{\SOME}{\mathtt{Some}}
\newcommand{\NONE}{\mathtt{None}}

\title{Operational Semantics % and Proof Rules
  for VMs in Hafnium} \date{\today}
\author{Zongyuan Liu}

\begin{document}
\maketitle

\section{Operational Semantics}

\subsection{Setting of Hafnium}
Hafnium is a type-1 hypervisor running on the AArch64 architecture(for now),
which is claimed can provide memory isolation between a set of virtual
machines(VMs) running on it. Hafnium provides memory isolation by managing the
stage-2 page tables of VMs. It controls the stage-2 translation by manipulating
entries in stage-2 page tables only according to the FF-A calls issued by VMs.
The hardware does the actual address translation by looking up page table
entries, which we assume working correctly. Therefore Hafnium can
guarantee that one VM can never access to the memory owned by another VM without
that VM's consent.

\begin{figure}[!h]
  \tikzset{
pagetable/.style = {draw, minimum width=2cm,text height = 0.20cm},
memory/.style= {rectangle , draw = black, thick, minimum width = 2cm},
address space/.style = { rectangle, draw=black!80, ultra thick,minimum width=2cm,minimum height=6cm}}

\pgfdeclarelayer{foreground}
\pgfsetlayers{main,foreground}
\centering
\begin{tikzpicture}[node distance=1cm, on grid]
    \begin{pgfonlayer}{foreground}
      \node [address space] (IPA)  at (-3,0) {};
      \node [address space] (PA) at (3,0) {};
      \node [above] at (PA.north) {PA};
      \node [above] at (IPA.north) {IPA};
    \end{pgfonlayer}
    \node [memory] (IP1)[fill = blue!50,minimum height = 1.5cm] at (-3,0.5) {VM$_{1}$};
    \node (X)[xshift = -3mm] at (IP1.north west) {$x$};
    \node [memory] (IP2)[fill = red!50,minimum height = 1.5cm] at (-3,-2) {VM$_{2}$};
    \node (Y)[xshift = -3mm] at (IP2.north west) {$y$};
    \node [memory] (PH)[fill = black!30,minimum height = 1.5cm] at (3,2.25) {};

    \node [pagetable] (PT1) at (3,2.25){PT$_{1}$};
    \node [pagetable] (PT2) at (3,1.75){PT$_{2}$};
    \node [above] at (PT1.north) {Hypervisor};

    \node [memory] (P1)[fill = blue!50,minimum height = 1.5cm] at (3,0.5) {VM$_{1}$}edge[<-] (IP1.east |- P1.west);
    \node (X')[xshift = -3mm] at (P1.north west) {$x$};
    \node [memory] (P2)[fill = red!50,minimum height = 1.5cm] at (3,-2) {VM$_{2}$}edge[<-] (IP2.east |- P2.west);
    \node (Y')[xshift = -3mm] at (P2.north west) {$y$};
    \node (E1)[minimum height = 0.5cm] at (0,0.8) {$x \mapsto x$};%edge[<-] (PT1.west);
    \node (E2)[minimum height = 0.5cm] at (0,-1.7) {$y \mapsto y$};%edge[<-] (PT2.west);

  \end{tikzpicture}
 \caption{Stage-2 Memory Translation}
  \end{figure}
For the sake of simplicity, stage-2 page tables managed by the Hafnium are
simply one-to-one mappings, i.e. the IPAs are always equal to PAs. Besides, it
is also the case for the stage-1 page table of the Hafnium itself.
For instance in Figure 1, the blue block whose $\PID$ is $x$ is a page owned by
VM1, and the red box is a page owned by VM2. All page tables are in hypervisor's
memory so that VMs are not able to modify entries of page tables directly. They
have to ask the hypervisor for help. The page table of VM1 maps $x$ in IPA
space to $x$ in PA space, the same applies to VM2. Therefore, we say if we
consider stage-2 page tables as functions, then they are actually always
identical functions. All we care is if $\PID$ of a page is in the domin of a
function(a VM's page table). If so, then the VM owns the memory page.


FF-A framework is designed as a protocol for components running on the ARM-A
processor, the main purpose of which is to allow components in the normal world
to communicate with components in the secure world. While in Hafnium, VMs and
the hypervisor are all counted as components residing in the normal world. The
FF-A framework serves as an approach for VMs to do message passing and
memory sharing with each other. We will see some examples of how exactly the
FF-A framework is utilized in Hafnium later.

One can read more details on the Hafnium architecture
\href{https://review.trustedfirmware.org/plugins/gitiles/hafnium/hafnium/+/HEAD/docs/Architecture.md}{here}.

\subsection{Execution Configuration}
\todo{later: improve error handling} The general purpose of the operational
semantics is to reason about programs written in assembly language running on
VMs. Therefore, in our operational semantics, we abstract away the Hafnium
hypervisor, considering the whole system only consists of several virtual
machines plus some additional information for the FF-A framework.

\begin{figure}
  \begin{align*}
    \phi &\in \CONF &\defined &list(\STATE) \times \MEM \times \SSS \\
    \delta &\in \STATE &\defined &list(\PID) \times \REGS \times \MB \\
    \pi & \in \MB &\defined &option(\PID) \times option(\PID \times \text{Bool} \times \WORD \times \VMID) \\
    p & \in \PID &\defined  &[ 0, \PPIDMAX ] \\
    r & \in \REGS &\defined  &\REGNAMES \maps \WORD \\
    n & \in \REGNAMES &\defined &\text{SysRegs} \cup \text{GenRegs} \\
    m & \in \MEM &\defined  &\ADDR \maps \WORD \\
    a & \in \ADDR &\defined  &[ 0, \PAMAX ] \\
    w & \in \WORD &\defined  &[ 0, \PWMAX ] \\
    s & \in \SSS &\defined  &list(\PID \times \VMID) \\
    v & \in \VMID &\defined  &[ 0, \PVMMAX ] \\
      & \;\;\;\; \text{SysRegs} &\derived & \mathtt{NV} | \mathtt{CNT\_VAL} | \mathtt{CNT\_CTL} | \dots \\
      & \;\;\;\; \text{GenRegs} &\derived & \mathtt{pc} | \mathtt {R0} | \mathtt{R1} | \dots
  \end{align*}
  \caption{Execution Configuration: VM States, Global Memory, and Share States.}
\end{figure}
Figure 2 shows the definition of execution configuration, which includes three
components: $\STATE$s of all VMs, a $\MEM$ shared with all VMs, and a $\SSS$
storing necessary information for memory sharing FF-A requests.

Normally, the state of a machine includes values of all
registers of that machine plus values of memory at all locations. In our case,
we have multiple machines. A naive approach to write down the state of all VMs
is to record their states separately. However, we only apply it to registers and
combine their memory together as a global memory. The global here means one VM
could be able to access memory of another VM(in the case of memory sharing).

The definition of $\MEM$ is straightforward. While the $\STATE$ consists of not
only registers, but also some $\PID$s.
%\todo{Lars: shouldn't there be some condition expressing that the memory mapped
%  by pages belonging to different VMs do not overlap ?}
The list of $\PID$ notes $\PID$s of all
pages that one VM owns, which is in principle determined by the stage-2 page
table of that VM.
Somehow, the memory isolation property might be able to be derived
by looking at the disjointness among these lists. Namely, if none of $\PID$s is in
lists of two VMs, we may argue that their memory are isolated from each other.
But, one should be careful to say it if there are any memory sharings, where the $\PID$
of the shared page will appear in two lists. Fortunately, it is feasible to tell
whether any memory sharing is happening by looking at the $\SSS$, which is responsible
for tracking all memory sharing operations.

Despite page tables essentially are maps, we instead use a mathematical list of
$\PID$s as the abstract page table of a VM.
% \todo{Lars: I don't understand this para}
We argue using list instead of map is sufficient to record all the necessary
information for stage-2 translation. Because as mentioned before, a $\PID$ in IP address
space is always equal to the corresponding one in the physical address space.
Namely, we always have entries like $x \mapsto x$ in stage-2 page tables.
Another benefit of this mapping scheme is that we can omit stage-2 translation entirely.



There are two kinds of registers in the model, general registers and system
registers. System register can only be accessed through two special
instructions. Thus, they usually are not involved in computation. Instead, they
are used for specific purpose like storing system state, changing hardware
behaviors, and etc. $\mathtt{NZ}$ is one of system registers, which means one is
only able to access to this register if it is at a high enough Exception Level.
This register is crucial to comparing and jumping instructions. It has similar
functionality as the
\href{https://developer.arm.com/docs/ddi0595/h/aarch64-system-registers/nzcv}
{$\mathtt{NZCV}$ register} in real Arm-A processors. Besides, we included two
timer registers as system registers as well.


The third components of a State is $\MB$ which is used for messaging. $\MB$ has
a RX and a TX buffer. The size of those two buffers is exactly one page, which
is consistent to the implementation of Hafnium. The reason that they are
embraced by an $option$ is that the two pages are uninitialized. There is a FF-A
call through which a VM can assign two pages it owns as its RX and TX pages.
Afterwards, the RX/TX pages are not strictly possessed by the VM anymore. In
addition, VM is no longer able to reassign other pages as new RX/TX pages, i.e.
RX/TX pages of a VM can only be configured once. The TX page is only writable
and RX is only readable to the VM, so that the VM can write a message into the
TX page and read from the RX page. Only the $\PID$ of the TX page needs to be
remember. Whereas for the RX buffer, the state of the buffer(whether a message
is ready), the length of the received message, and the sender of the message are
also necessary, in order to ensure the system works correctly.

To explain why we defined the $\SSS$, we need to elaborate on how memory sharing is
specified in the FF-A framework, which we won't do until Section 1.5 when we
show semantics of instructions. For now, it is enough for readers to know that $\PID$ is
the page to share, $\VMID$ the receiver of the sharing, and both are essential
to perform memory sharing. In Hafnium implementation, there is a similar but
much more complicated data structure to record those information(and more),
which is maintained by the Hafnium itself. Since we don't have the hypervisor in
our model, we added $\SSS$ into the execution configuration.

Some constants are introduced as well to specify basic configurations of the model. In
the context of AArch64, $\PAMAX$ should be $2^{\PABITS} - 1$ where
$\PABITS = 48$, $\PWMAX = 2^{\PWBITS} -1$ where $\PWBITS = 64$, and
$\PPIDMAX = 2^{\PPIDBITS}-1$ where $\PPIDBITS = \PABITS - \PPBITS = 36$.
$\PVMMAX$ makes sure we only have finite number of VMs.


\subsection{Syntax and Instructions}
\begin{figure}[h!]
  \begin{align*}
    \mu &\in \MODE &\derived & \mathtt{ExecInstr} \; v | \mathtt{Repeat} \; \mu | \mathtt{Done} \; \theta \\
    \theta &\in \DONE &\derived & \NXT{v} | \mathtt{Halt} | \mathtt{Fail}\\
    \\
    instr & \in  \INSTR &\derived & \instrm{br} \; r |\instrm{bne} \; r \; r |
                                    \instrm{mov} \; r \; w | \instrm{ldr} \; r\; r|
                                    \instrm{str} \; r \; r | \instrm{add} \; r \; r \; r |
                                    \instrm{sub} \; r \; r \; r | \instrm{cmp} \; r \; r \\
        & & & | \instrm{fail} | \instrm{halt} | \instrm{hvc} |\instrm{mrs} \; r\;r | \instrm{msr} \; r \; r
  \end{align*}
  \caption{Syntax and Machine Instructions}
\end{figure}
The syntax and instructions included in our model are shown in Figure 3. The
syntax of the expression is uncomplicated. Generally speaking, $\EI{v}$ is for
executing a single instruction in VM $v$ and $\DN{\theta}$ implies the result of
the execution. The result could be successful or failed. In case of success, we
either proceed on the next instruction in VM $v$ with $\NXT{v}$ or halt.

There are two major reasons why we didn't use instructions as expressions. On
one hand,
instructions are related to the execution configuration, their encodings are
stored in the memory. However, we want something independent of the
configuration as expressions so that we can write down the rules in a more
elegant way. On the other hand, $\mathtt{Repeat}$ acts like a context.
Therefore it is more straightforward and natural to come up with the bind rule
in the program logic, comparing to a sequence of instructions.


We included a subset of AArch64 instructions and believe that these instructions
are sufficient to construct interesting programs. Besides, it would be
effortless to include new instructions. All we need to do is adding the
instruction and giving a semantic interpretation. One minor thing to mention is
that we assume addresses in instructions are IPAs, i.e. they have undergone
stage-1 translation. Even though it makes our model slightly unrealistic, we argue
that it is totally acceptable since our main target is stage-2 memory access.

\subsubsection{\instr{hvc} Instruction}
In reality, all sorts of communications
between VMs are indirect in Hafnium system(done through FF-A function calls).
Namely, the hypervisor involves in. For instance, for memory donation, page
tables need to be modified while only the hypervisor has high enough Exception
Level and access to the memory where page tables are stored. The instruction
\texttt{hvc} would be executed with some arguments by the VM to raise the
Exception Level and invoke the hypervisor to do the actual work. It more or less
acts like a system call in OS.
% However, since our program language for VMs is
% assembly and the implementations of FF-A functions are written in C, we choose
% not to implement FF-A functions in assembly language but introduce new
% instructions with appropriate semantics describing what these functions do.
% There are currently two instructions for memory sharing, among that
% \texttt{memd} is for donating a page, and \texttt{memr} is for retrieving a
% page. We will talk about their semantics later.



\todo{later:initial state?}

\subsection{Reduction rules}
\subsubsection{Notations}
An execution configuration $\phi$ is a triple, where $\phi.\Delta$
is a list of $\STATE$,$\phi.m$ the global memory, and $\phi.s$ the $\SSS$. $\Delta[i]$ is used
to notate the $\STATE$ of VM $i$ in $\Delta$. Furthermore, we utilize the field
access notation to express the list of $\PID$ as $\Delta[i].ps$, the RX buffer as $\Delta[i].\pi_{r}$,
and the TX buffer as $\Delta[i].\pi_{t}$.
We overload the square bracket notation to access
the value corresponding to a given key in $\REGS$ and $\MEM$ mappings. Occasionally, we
borrow $\in$ and $\setminus$ operators from sets, applying on lists. We still require
the property that elements are ordered sometimes, therefore these
operators might only be considered as operators for finding
and removing elements from a list respectively.

%\todo{Lars: later we should check if/when we rely on the lists being ordered}

% In addition, mappings are treated as functions so that they have
% domain and codomain.

\subsubsection{Rules}


\begin{figure}[h!]
  \begin{mathpar}
    \inferrule[RepeatExec] {(\EI{v},\, \phi) \rightarrow (\DN{\theta} ,\,
      \phi')} {(\RP{\EI{v}} ,\, \phi) \rightarrow (\RP{\DN{\theta}} ,\, \phi')}
    \and \inferrule[RepeatHalt/Fail] {\theta = \mathtt{Halt} \lor \theta =
      \mathtt{Fail}} {(\RP{\DN{\theta}} ,\, \phi) \rightarrow (\DN{\theta} ,\,
      \phi)} \and \inferrule[RepeatNext]{} {(\RP{\DN{\NXT{v}}} ,\, \phi)
      \rightarrow (\RP{\EI{v}} ,\, \phi)} \and \inferrule[ExecInstr]{}
    {{(\EI{v},\, \phi) \rightarrow \left\{
          \begin{array}{ll}
            \sem{\decode(w_i)}(\phi.\Delta, \phi.m, \phi.s ,v)
            & \mathrm{if} \;\SOME(a_i) = \valida(\phi.\Delta[v], \mathtt{pc},V) \land m[a_i]=w_i \\
            (\DN{\mathtt{Fail}},\, \phi) & \mathrm{otherwise}
          \end{array} \right.}
    }
    \and
    \begin{aligned}
      \valida(\delta,r,P) &=\left\{ \begin{array}{ll}
                                      \SOME(a_i) & \text{if} \; a_i = \delta.r[r] \\
                                                 &\land \big( (P=V \land \pid(a_i) \in \delta.ps) \\
                                                 &\lor (P=R \land (\pid(a_i)\in \delta.ps \lor \SOME(\pid(a_i),-,-,-)=\delta.\pi_r)) \\
                                                 &\lor (P=W \land (\pid(a_i)\in \delta.ps \lor \SOME(\pid(a_i))=\delta.\pi_t))\big) \\
                                    \NONE & \text{otherwise}
                                  \end{array}
                                \right. \\
      \pid(a) &= a >> \PPBITS
    \end{aligned}
  \end{mathpar}
  \caption{Reduction Steps.}
  % \vspace{-0.5cm}
\end{figure}

In Figure 4, the \refr{RepeatExec} rule combined with the \refr{RepeatNext} and
\refr{RepeatHalt/Fail} rules are applied to proceed with the execution.

In \refr{ExecInstr}, the input of the $\decode$ function is a $\WORD$
$w_{i}$(for instruction word) obtained from $\MEM$. The $\decode$ function
decodes it to the corresponding $\INSTR$ which has a predefined semantic
interpretation. Applying the interpretation to execution configuration $\phi$
and $\VMID$ v will give us a new configuration after executing the instruction
on VM $v$. If $w_{i}$ is an invalid encoding, we decode it as $\mathtt{fail}$.

To obtain the encoding of the next executing instruction $w_{i}$, we first get the
value of the \texttt{pc} register of VM $v$ as $w_{i}$, which is the address of the
$w_{i}$ in the global memory. Before decoding $w_{i}$, we have to ensure that the
memory access is valid, i.e., $a_{i}$ is in the range of a page owned by $v$.
The validation is done by $\valida$ function.


\subsection{Semantic Interpretations of Instructions}

The last piece of the puzzle of operational semantic
is the semantic interpretations of instructions describing how to proceed on
execution, which is shown in Figure 5.

The semantics interpretations of AArch64 instructions are generally trivial. The
only worth-mentioned point is the conditions of \instr{ldr} and \instr{str}. The
validity of the target memory accessing address has to be checked to guarantee
the memory isolation property. Note we give different last arguments in
$\valida$. $R$ indicates it is a read operation, therefore it is allowed to let
the RX buffer be the location to be read. Similarly, the TX buffer could be the
location of write operations.


\subsubsection{Notations}
Regarding the modification of the $\STATE$, we use for instance $\Delta'$ to
implies it is modified, distinguishing from the original $\Delta$. Excepting
what we state explicitly, the rest components of $\Delta'$ are identical to the
counterparts in $\Delta$. Informally, one can understand it as we first make a
copy of the $\Delta$ as $\Delta'$, then do some minor modifications on
$\Delta'$.

Note that we only use $\mathtt{mathtt}$ font to represent actual registers.
While the regular \emph{Italic} font is used for any general registers. For
instance, $r_{1}$ doesn't have to be the $\mathtt{R1}$ register.

The primary VM always has $\VMID$ 0.

\newcommand{\reg}[1]{\texttt{{#1}}}

\subsubsection{\instr{hvc} Calling Conventions}
All FF-A calls are implemented as synchronous exceptions, since they need higher
EL to complete. The \instr{hvc} instruction is used to generate such exceptions
that will be handled by the hypervisor. In
\href{https://developer.arm.com/documentation/den0028/latest}{this} document,
calling conventions of hvc calls are specified, which are complied with by FF-A
calls as well. Readers will see we followed the conventions in the semantic
interpretation of \instr{hvc}.

%Most of FF-A calls are so-called fast calls, which means these calls executions that are atomic from the view of VMs.

A FF-A call contains a function identifier determining the function to be
invoked, several arguments, and the return. All of these components are stored
in registers. In AArch64, \reg{R0}-\reg{R7} registers are used. In particular,
\reg{W0} identified as the least significant 32-bits of \reg{R0} has the role of
function identifier in FF-A calls. Furthermore, \reg{W1}-\reg{W6} works as
parameter registers, which implies FF-A can have at maxinum six arguments. For
return value, \reg{W0}-\reg{W3} are used. Error Codes are returned in \reg{W0}.


\newcommand{\sema}[1]{\sem{ {#1} }(\Delta,m,s,v)}
\newcommand{\llen}[1]{\text{len}( {#1})}
\newcommand{\leftshift}{\!\!\!\!}
\newcommand{\DNXT}[2]{(\DN{\NXT{ {#1} }}, {#2})}
\newcommand{\nextt}{\text{tick}}
% \newcommand{\toword}[1]{\text{toWRD}(\text{{#1}})}
\newcommand{\toword}[1]{\text{{#1}}}
\begin{figure}[h!]
  \begin{adjustwidth}{-1cm}{}
    \begin{tabular}[t]{|l|L L|l|l|}
      \hline
      Instr$(i)$ &\sema{i} & \text{where} &  \multicolumn{2}{l|}{Conditions} \\ \hline \hline
      \instr{fail}&\leftshift (\DN{\mathtt{Fail}}, (\Delta,m,s)) & & \multicolumn{2}{l|}{} \\ \hline
      \instr{halt}&\leftshift (\DN{\mathtt{Halt}}, (\Delta,m,s)) & & \multicolumn{2}{l|}{} \\\hline
      \instr{br} $r$&\leftshift \nextt(\Delta',m,s,\text{id},v,v)  & \Delta'[v].r[\mathtt{pc}]=\Delta[v].r[r] & \multicolumn{2}{l|}{$r \in \text{GenRegs}$} \\\hline
      \multirow{2}{*}{\instr{bne} $r$}&\multirow{2}{*}{$\leftshift \nextt(\Delta',m,s,\text{id},v,v)$}
                               & \Delta'[v].r[\mathtt{pc}]= \Delta[v].r[r] & $\Delta[v].r[\mathtt{NZ}].z=1$& $r \in \text{GenRegs}$\\\cline{3-4}
                               & & \Delta'[v].r[\mathtt{pc}]= \Delta[v].r[\mathtt{pc}]+1 &otherwise& \\\hline
      \instr{mov} $r$ $w$&\leftshift \nextt(\Delta', m, s,\updpc,v,v)  & \Delta'[v].r[r]=w & \multicolumn{2}{l|}{$r \in \text{GenRegs}$} \\\hline
      \instr{ldr} $r_{1}$ $r_{2}$&\leftshift \nextt(\Delta', m, s,\updpc,v,v) & \Delta'[v].r[r_{1}]=m[a]  &
                                \multicolumn{2}{l|}{$\!\!\!\!\! \begin{array}{l}r_{1},r_{2}\in \text{GenRegs}\\\SOME(a)=\valida(\Delta[v],r_{2},R)\end{array}$} \\\hline
      \instr{str} $r_{1}$ $r_{2}$&\leftshift \nextt(\Delta, m', s,\updpc,v,v) & m'[a]=\Delta[v].r[r_{2}]&
                                \multicolumn{2}{l|}{$\!\!\!\!\! \begin{array}{l}r_{1},r_{2}\in \text{GenRegs}\\\SOME(a) =\valida(\Delta[v],r_{1},W)\end{array}$} \\\hline
      \instr{add} $r_{1}$ $r_{2}$ $r_{3}$&\leftshift \nextt(\Delta', m, s,\updpc,v,v) &\leftshift \begin{array}{l}\Delta'[v].r[r_{1}]= \Delta[v].r[r_{2}] + \Delta[v].r[r_{3}] \end{array} & \multicolumn{2}{l|}{$r_{1},r_{2},r_{3} \in \text{GenRegs}$} \\\hline
      \instr{sub} $r_{1}$ $r_{2}$ $r_{3}$&\leftshift \nextt(\Delta', m, s,\updpc,v,v) &\leftshift \begin{array}{l}\Delta'[v].r[r_{1}]= \Delta[v].r[r_{2}] - \Delta[v].r[r_{3}] \end{array} & \multicolumn{2}{l|}{$r_{1},r_{2},r_{3} \in \text{GenRegs}$} \\\hline
      \multirow{4}{*}{\instr{cmp} $r_{1}$ $r_{2}$}&\multirow{4}{*}{$\leftshift \nextt(\Delta', m, s,\updpc,v,v)$}
                                 & w = \Delta[v].r[r_{1}] - \Delta[v].r[r_{2}] & \multicolumn{2}{l|}{$r_{1},r_{2} \in \text{GenRegs}$} \\\cline{3-4}
                                 & & \Delta'[v].r[\mathtt{NZ}]= 1 & $w = 0$ & \\\cline{3-4}
                                 & & \Delta'[v].r[\mathtt{NZ}]= 2 & $w < 0$ & \\\cline{3-4}
                                 & & \Delta'[v].r[\mathtt{NZ}]= 0 & otherwise &\\\hline
      \multirow{33}{*}{\instr{hvc}}&\leftshift \nextt(\Delta', m, s',\updpc,v,v)
                                    &\!\!\!\!\! \begin{array}{l}
                                               \Delta'[v].ps=\Delta[v].ps \setminus \{\pid(a_p)\}  \\
                                               v_r =  \Delta[v].r[\mathtt{R2}] \\
                                               s' = s \append [(\pid(a_p), v_r)]\\
                                               \Delta'[v].r[\mathtt{R2}]=\llen{s'}\\
                                               \Delta'[v].r[\mathtt{R0}]=\toword{SUCCESS}
                                             \end{array}
                                    & \multicolumn{2}{l|}{$\leftshift\begin{array}{l}
                                                    \Delta[v].r[\mathtt{R0}]=\toword{MEM\_DNT}\\
                                                    \SOME(a_p)=\valida(\Delta[v],\mathtt{R1},V) \\
                                                    v_r < \llen{\Delta}\\
                                                    v \neq v_r
                                                  \end{array}$}\\\cline{2-5}
      &\leftshift \nextt(\Delta', m, s',\updpc,v,v)
                           &\!\!\!\!\! \begin{array}{l}
                                         \Delta'[v].ps=\Delta[v].ps \append [p]\\
                                         s'= s \setminus \{(p,v)\}\\
                                         \Delta'[v].r[\mathtt{R0}]=\toword{MEM\_RTRVP}
                                       \end{array}
                 &\multicolumn{2}{l|}{$\leftshift\begin{array}{l}
                                                   \Delta[v].r[\mathtt{R0}]=\toword{MEM\_RTRVQ}\\
                                                   s[\Delta[v].r[\mathtt{R1}]] = (p, v)\\
                                                   p \notin \Delta[v].ps
                                 \end{array}$} \\\cline{2-5}
      & \multirow{5}{*}{$\leftshift \nextt(\Delta', m, s,\updpc,v, v_n)$}
                                      & v_n=\Delta[v].r[\mathtt{R1}]
                                          & \multicolumn{2}{l|}{\multirow{2}{*}{$\leftshift \begin{array}{l}
                                                                                              \Delta[v].r[\mathtt{R0}]=\toword{RUN}\\
                                                                                              v=0 \land v_n < \llen{\Delta}
                                                                                              \end{array}$}}\\
                                 & &\SOME(p_r,b,w_s,v_s)=\Delta[v_n].\pi_r &\multicolumn{2}{l|}{\multirow{2}{*}{}}\\\cline{3-4}
                                 & &\!\!\!\!\!\begin{array}{l}
                                              \Delta'[v_n].r[\mathtt{R0}]=\toword{MSG\_SEND}\\
                                              \Delta'[v_n].r[\mathtt{R1}]=\text{comb}(v_s,v_n)\\
                                              \Delta'[v_n].r[\mathtt{R3}]=w_s
                                                        \end{array}& $b$ & \\\cline{2-5}
      & \leftshift \nextt(\Delta', m, s,\updpc, v, 0)
                                 &\!\!\!\!\! \begin{array}{l}
                                               \Delta'[0].r[\mathtt{R0}]=\toword{\YIELD}\\
                                               \Delta'[0].r[\mathtt{R1}]=v
                                               \end{array}& \multicolumn{2}{l|}{$\Delta[v].r[\mathtt{R0}]=\toword{YIELD}$} \\\cline{2-5}
      \multirow{8}{*}{}&\multirow{8}{*}{$\leftshift \nextt(\Delta', m, s,\updpc, v, v_n)$}
                                 & \SOME(p_r,b,w_s,v_s)=\Delta[v].\pi_r& \multicolumn{2}{l|}{$\Delta[v].r[\mathtt{R0}]=\toword{MSG\_WAIT}$} \\\cline{3-4}
                                 & &\!\!\!\!\!\begin{array}{l}
                                              v_n=v\\
                                              \Delta'[v_n].r[\mathtt{R0}]=\toword{\MSGS}\\
                                              \Delta'[v_n].r[\mathtt{R1}]=v_s\\
                                              \Delta'[v_n].r[\mathtt{R3}]=w_s
                                              \end{array} & $b$&\\\cline{3-4}
                                 & &\!\!\!\!\!\begin{array}{l}
                                              v_n=0\\
                                              \Delta'[v_n].r[\mathtt{R0}]=\toword{\MSGW}\\
                                              \Delta'[v_n].r[\mathtt{R1}]=v
                                 \end{array}& $!b$& \\\cline{2-5}
      \multirow{11}{*}{}& \multirow{11}{*}{$\leftshift \nextt(\Delta', m', s,\updpc,v,v_n)$}
                           & v_r=\Delta[v].r[\mathtt{R1}]&\multicolumn{2}{l|}{\multirow{3}{*}{$\leftshift\begin{array}{l}
                                                                                                   \Delta[v].r[\mathtt{R0}]=\toword{MSG\_SEND}\\
                                                                                                   \Delta[v].\pi_{t}=\SOME(p_t)
                                                                                                   \end{array}$}} \\
                                 & & w_s=\Delta[v].r[\mathtt{R2}]& \multicolumn{2}{l|}{}\\
                                 & & \SOME(p_r,b,-,-)=\Delta[v_r].\pi& \multicolumn{2}{l|}{} \\\cline{3-4}
                                 & & \!\!\!\!\!\begin{array}{l}
                                                 v_n=0\\
                                                 \Delta'[v_r].\pi=\SOME(p_r,\mathtt{true},w_s,v)\\
                                                 m'=\text{memcpy}(m,p_t,p_r,w_s)\\
                                                 \Delta'[v].r[\mathtt{R0}]=\toword{\SUCC}\\
                                                 \Delta'[0].r[\mathtt{R0}]=\toword{\MSGS}\;\text{if}\;v\neq 0\\
                                                 \Delta'[0].r[\mathtt{R1}]=\text{comb}(v,v_r)\;\text{if}\;v\neq 0
                                               \end{array} & $!b$ &\\\cline{3-4}
                                & &\!\!\!\!\!\begin{array}{l}
                                               v_n=v\\
                                               \Delta'[v].r[\mathtt{R0}]=\toword{\BUSY}
                                             \end{array} & $b$&\\\cline{2-5}
      & \leftshift  \nextt(\Delta', m, s,\updpc, v, v)& \Delta'[v].\pi_r = \SOME(p_r,\mathtt{false},-,-)
                                          &\multicolumn{2}{l|}{$\leftshift \begin{array}{l}
                                                                             \Delta[v].r[\mathtt{R0}]=\toword{MSG\_RCV}\\
                                                                             \Delta[v].\pi_{r}=\SOME(p_r,\mathtt{true},-,-)
                                                                           \end{array}$} \\\hline
      \instr{mrs} $r_{1}$ $r_{2}$&\leftshift \nextt(\Delta', m, s,\updpc,v,v)  & \Delta'[v].r[r_1]=\Delta[v].r[r_2] & \multicolumn{2}{l|}{$r_{2}\in \text{SysRegs}\land r_{1}\in \text{GenRegs}$} \\\hline
      \instr{msr} $r_{1}$ $r_{2}$&\leftshift \nextt(\Delta', m, s,\updpc,v,v)  & \Delta'[v].r[r_1]=\Delta[v].r[r_2] & \multicolumn{2}{l|}{$r_{1}\in \text{SysRegs}\land r_{2}\in \text{GenRegs}$} \\\hline
    \end{tabular}
  \end{adjustwidth}
  \caption{Instruction Semantics.}
\end{figure}
\todo{later: consider overflow}
\begin{figure}[!h]
  \begin{align*}
    \updpc(\Delta,m,s,v)&=(\Delta',m,s)\ \; \text{where}\; \Delta'[v].r[\mathtt{pc}] = \Delta[v].r[\mathtt{pc}]+1\\
    \text{id}(\Delta,m,s,v)& = (\Delta,m,s)\\
    \nextt(\Delta,m,s,f,v,n)&= \left\{\!\!\!\!\begin{array}{lll}
                                \DNXT{0}{f(\Delta',m,s,v)} &\text{where }&\Delta'[v].r[\mathtt{CNT\_VAL}] = \Delta[v].r[\mathtt{CNT\_VAL}] -1,\\
                                & & \Delta'[0].r[\mathtt{CNT\_VAL}] = \Delta[0].r[\mathtt{CNT\_VAL}] -1,\\
                                & &\Delta'[0].r[\mathtt{CNT\_CTL}] = 0,\\
                                & &\Delta'[0].r[\mathtt{R0}]=\toword{INTERRUPT},\\
                                & &\Delta'[0].r[\mathtt{R1}] = v\\
                                & \text{if}&(\Delta[v].r[\mathtt{CNT\_VAL}] -1 \le 0 \land\Delta[v].r[\mathtt{CNT\_CTL}] = 1)\\
                                & &\lor(\Delta[0].r[\mathtt{CNT\_VAL}] -1 \le 0\land\Delta[0].r[\mathtt{CNT\_CTL}] = 1)\\
                                \\
                                \DNXT{n}{f(\Delta',m,s,v)} &\text{where}&\Delta'[v].r[\mathtt{CNT\_VAL}] = \Delta[v].r[\mathtt{CNT\_VAL}] -1\\
                                & &\Delta'[0].r[\mathtt{CNT\_VAL}] = \Delta[0].r[\mathtt{CNT\_VAL}] -1\\
                                & \text{otherwise}\\
                                              \end{array}  \right.\\
    \text{comb}(w_{1},w_{2})&=w_{1}<<(\PWBITS/2)+w_{2}
  \end{align*}
  \caption{Instruction Semantics(Cont.).}
\end{figure}
\subsubsection{Memory Sharing}
We introduced two FF-A functions for memory sharing between VMs. The MEM\_DNT is
invoked by the donor(Sender $v$) to donate a page with $\PID$ $a_{p}$ stored in
the $\mathtt{R_{1}}$ register to the recipient(Receiver) whose $\VMID$ $v_{r}$
is stored in the $\mathtt{R_{2}}$ register. According to the specification of
the FF-A framework, MEM\_DNT mainly does three things: 1. checking(confirm if
$a_{p}$ is a valid address of $v$); 2. removing the $\PID$ of the donated
page($\text{pid}(a_{p})$) from sender's page table($\Delta[v].ps$) and 3.
keeping donation details($\text{pid}(a_{p})$ and $v_{p}$) in the hypervisor(in
$\SSS$ $s$) as a pair and returning a handle $\text{len}(s')$ (which is a fresh index
in $\SSS$) via the result register.

However, MEM\_DNT merely does half of the donation. The second half is completed
by the receiver $v$ with the invocation of MEM\_RTERVQ. Hypervisor reads the
information of the donation (the pair $(p,v)$) from $\SSS$ $s$ through the
handle(stored in $\mathtt{R1}$) passed by the receiver. Then it confirms if $v$ is
indeed the receiver by incepting whether the second component of the pair is
$v$. If so, the hypervisor adds the $\PID$ of the donated page $p$ into the page
table of the receiver$\Delta[v].ps$. The difference between the implementation
and our semantic interpretation is that we remove the pair from $\SSS$ while it
is kept and has further usages in the implementation. Finally, the hypervisor
returns MEM\_RTRVP as a response to the caller via the result register.


\subsubsection{Message Passing and Scheduling}
We will elaborate on message passing and scheduling together in this section as
these two are closely related. Loosely speaking, sending and waiting for
messages expect the scheduler to schedule a certain VM, usually either the
sender or the receiver. The purpose is to get the sender or the
receiver notified.

Let's talk about the less-complicated scheduling first. In Hafnium, the
scheduler resides in the primary VM which usually uses its thread scheduler as
the VM-level scheduler. To achieve this, the primary VM allocates threads for all
VMs, and then treat them as regular threads. However, to let the whole system
function correctly, several expectations are given to the primary VM's scheduler
according to the FF-A specification. We will mention them when we meet.

Making use of the primary VM's scheduler instead of writing a scheduler in the
hypervisor dramatically reduces the verification work of the hypervisor. Although
the downside is we lose the availability of all secondary VMs.

To make the scheduling more realistic, we introduced timer registers and a
mechanism working like the timer interrupt(not an actual interrupt!) in our
model. The \texttt{CNT\_VAL} register stores the current value of the
timer countdowns by $1$ whenever executing an instruction. When the timer is
enabled by setting \texttt{CNT\_CTL} to 1 and its value becomes(or less than)
zero , the currently running VM will be preempted, switching back to the primary
VM, and meanwhile, notifying the primary VM who was running before the
``interrupt''. These tasks are done by the tick function. An interesting point
of the tick function is that it modifies not only the timer of the current VM but
also the primary VM. The primary VM then is capable of interrupting a running
secondary VMs by setting its timer, preventing secondary VMs from occupying
unlimited CPU time. One may also notice that the notification is carried out by
assigning values to registers of the primary VM, which is exactly the foregoing hvc
call conventions.
% We say it is the mechanism for hypervisor to communicate with VMs
% regulated by FF-A framework. Intuitively, it can be seen as function calls to
% VMs, in which $\mathtt{r_{0}}$ stores the function name and the rest store
% arguments. We call these registers parameter registers.
In the $\INT$ case, the hypervisor invokes primary VM to handle the ''timer
interrupt'' towards the preempted VM. The scheduler will decide who is the next
to run and switch with the RUN FFA function(by executing \instr{hvc}).

% In Hafnium, the expectation to the scheduler is checking if the $\TIMER$ of
% that VM is zero. If not, the scheduler must execute \instr{run} to allow the VM
% to continue.

The RUN function can only be invoked by the primary VM, allowing the primary VM to pass
the control to the VM whose $\VMID$ is stored in $r$ with the help of the
hypervisor. The hypervisor will check if the caller is the primary VM($v=0$),
and whether the given $\VMID$ $v_{n}$ exists($v_{n} < \text{len}(\Delta)$).
Next, the hypervisor examines the state of $\MB$ of the next running VM. If the
message in $\MB$ is ready to read($b=\mathtt{true}$), the hypervisor
additionally sets parameter registers of VM $v_{n}$, notifying the VM along with
the sender($v_{s}$) and the length of the message($w_{s}$).

The second scheduling related FFA call is YIELD. It is called by a VM when it
wants to yield the CPU and pass control to the scheduler. The semantic of this
function is trivial, it just informs the scheduler the previous running VM $v$
just yielded. The expectation to the scheduler is it must not run that VM again
immediately.

% However, there is an expectation for $\YIELD$ to the primary VM,
% which is that the yielding VM must be run through \instr{run} after a given
% timeout.

The MSG\_WAIT is used by a VM to wait for a message. However in fact, it is
essentially a scheduling FFA function. When it is invoked by a VM $v$, the
hypervisor will inspect the $\MB$. If there is a ready
message($b=\mathtt{true}$), the control is given back to the VM($v_{n}=v$),
notifying it in the same manner as RUN. Otherwise, the hypervisor informs the
scheduler that the VM is waiting and switch to the scheduler($v_{n}=0$).
Intuitively, the hypervisor forwards the MSG\_WAIT to the scheduler. The scheduler
is expected not to run that VM again unless a message to the VM is sent.

MSG\_SEND is the core of the FFA message passing mechanism. After the VM $v$
writes a $w_{s}$-byte message to its TX page, it invokes the hypervisor with
MSG\_SEND plus $w_{s}$ and the receiver VM $v_{r}$. The hypervisor then checks
if a message is ready in $v_{s}$'s $\MB$($b=\mathtt{true}$). If so, it returns
back to the sender $v$ with the error code $\text{BUSY}$ in the result register.
Otherwise($b=\mathtt{false}$), it copies the message from $v$'s TX page($p_{t}$)
to $v_{s}$'s RX page($p_{r}$), telling $v$ the operation succeeds and giving the
control to the scheduler($v_{n}=0$). When giving away the control, the hypervisor
sees if the sender is not the primary VM($v\neq 0$). If it is the case, the
hypervisor also needs to inform the scheduler who is sending a message to whom,
so that the scheduler can schedule accordingly. Otherwise, if the primary VM is
sending the message, then it already knew the sender and the receiver.
Therefore, it is unnecessary to use return registers.

MSG\_RCV is another trivial FFA function, its usage is emptying the $\MB$(by
setting $b=\mathtt{false}$) so that the $\MB$ can receive a new message.

%\section{Proof Rules}





\end{document}
