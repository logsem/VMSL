\documentclass[a4paper]{article}
\usepackage[a4paper]{geometry}
\usepackage{multicol}
\usepackage{amsmath}
\usepackage{mathpartir}
\usepackage{hyperref}
\usepackage{todonotes}
\usepackage{kpfonts}
\usepackage[T1]{fontenc}

% notations
\newcommand*{\defined}{\triangleq}
\newcommand*{\maps}{\rightarrow}
\newcommand*{\derived}{::=}
\newcommand*{\sem}[1]{\llbracket {#1} \rrbracket}


% definitions
\newcommand*{\CONF}{\text{ExecConf}}
\newcommand*{\STATE}{\text{State}}
\newcommand*{\MEM}{\text{GlobalMem}}
\newcommand*{\SSS}{\text{ShareStates}}
\newcommand*{\PID}{\text{PID}}
\newcommand*{\REGS}{\text{Registers}}
\newcommand*{\ADDR}{\text{Address}}
\newcommand*{\WORD}{\text{Word}}
\newcommand*{\VMID}{\text{VMID}}
\newcommand*{\REGNAMES}{\text{RegisterName}}
\newcommand*{\MODE}{\text{ExecMode}}
\newcommand*{\DONE}{\text{DoneState}}
\newcommand*{\INSTR}{\text{Instruction}}

% parameters
\newcommand*{\PABITS}{\text{ADDR\_BITS}}
\newcommand*{\PPBITS}{\text{PAGE\_BITS}}
\newcommand*{\PPIDBITS}{\text{PID\_BITS}}
\newcommand*{\PAMAX}{\text{ADDR\_MAX}}
\newcommand*{\PPMAX}{\text{PAGE\_MAX}}
\newcommand*{\PPIDMAX}{\text{PID\_MAX}}
\newcommand*{\PWBITS}{\text{WORD\_BITS}}
\newcommand*{\PWMAX}{\text{WORD\_MAX}}
\newcommand*{\PVMMAX}{\text{VM\_MAX}}


% instructions
\newcommand*{\instrm}[1]{\mathtt{#1}}
\newcommand*{\instr}[1]{\texttt{#1}}

% TODO: message passing instructions

% expressions
\newcommand*{\EI}[1]{\mathtt{ExecInstr} \; {#1}}
\newcommand*{\RP}[1]{\mathtt{Repeat} \; {#1}}
\newcommand*{\DN}[1]{\mathtt{Done} \; {#1}}
\newcommand*{\NXT}[1]{\mathtt{Next} \; {#1}}

% functions
\newcommand*{\decode}{\text{decode}}
\newcommand*{\valida}{\text{valida}}
\newcommand*{\updpc}{\text{updpc}}
\newcommand*{\pid}{\text{pid}}


% reference
\renewcommand{\DefTirName}[1]{\hypertarget{#1}{\TirName {#1}}}
\newcommand{\refr}[1]{\hyperlink{#1}{\TirName {#1}}}

% SOME/NONE
\newcommand{\SOME}{\mathtt{Some}}
\newcommand{\NONE}{\mathtt{None}}

\title{Operational Semantics and Proof Rules for VMs in Halfnium}
\date{\today}
\author{Zongyuan Liu}

\begin{document}
\maketitle

\section{Operational Semantics}

\todo{later: more realistic scheduling}
\subsection{Settings of Halfnium}
Halfnium is a type-1 hypervisor running on the AArch64 architecture(for now),
which is claimed can provide memory isolation between a set of virtual
machines(VMs) running on it. Halfnium provides memory isolation by managing the
stage-2 page tables of VMs. It controls the stage-2 translation by manipulating
entries in stage-2 page tables only according to the FF-A calls issued by VMs.
The hardware does the actual address translation by looking up page table
entries, which we assume acting correctly as described. Therefore Hafnium can
guarantee that one VM can never access to the memory owned by another VM without
that VM's consent.

For the sake of simplicity, stage-2 page tables managed by the Hafnium are
simply one-to-one mappings, i.e. the IPAs are always equal to PAs. Besides, it
is also the case for the stage-1 page table of the Hafnium itself.

FF-A framework are designed as a protocol for components running on the ARM-A
processor, the main purpose of which is to allow components in the normal world
to communicate with components in the secure world. While in Hafnium, VMs and
the hypervisor are all counted as components residing in the normal world. The
FF-A framework is then used as an approach for VMs to do message passing and
memory sharing with each other. We will see some examples of how exactly the
FF-A framework is used in Hafnium later.

One can read more details on the Hafnium architecture at \href{https://review.trustedfirmware.org/plugins/gitiles/hafnium/hafnium/+/HEAD/docs/Architecture.md}{here}.

\subsection{Execution Configuration}
\todo{later: improve error handling}
The general purpose of the operational semantics
is to reason about programs written in assembly language running on VMs.
Therefore, in our operational semantics, we abstract away the Halfnium
hypervisor, considering the whole system only consists of several virtual
machines plus some additional information for the FF-A framework.

\begin{figure}
  \begin{align*}
    \phi &\in \CONF &\defined &list(\STATE) \times \MEM \times \SSS \\
    \delta &\in \STATE &\defined &list(\PID) \times \REGS \times option(\PID \times \PID) \\
    p & \in \PID &\defined  &[ 0, \PPIDMAX ] \\
    r & \in \REGS &\defined  &\REGNAMES \maps \WORD \\
    n & \in \REGNAMES &\derived  &\mathtt{pc} | \mathtt{NZCV} | \mathtt {r_{0}} | \mathtt{r_{1}} | \dots \\
    m & \in \MEM &\defined  &\ADDR \maps \WORD \\
    a & \in \ADDR &\defined  &[ 0, \PAMAX ] \\
    w & \in \WORD &\defined  &[ 0, \PWMAX ] \\
    s & \in \SSS &\defined  &list(\PID \times \VMID) \\
    v & \in \VMID &\defined  &[ 0, \PVMMAX ]
  \end{align*}
  \caption{Execution Configuration: VM States, Global Memory and Share States.}
\end{figure}
Figure 1 shows the definition of execution configuration, which includes three
components: $\STATE$s of all VMs, a $\MEM$ shared to all VMs, and a $\SSS$
storing necessary information for memory sharing FF-A requests.

In general, when saying the state of a machine, it represents values of all
registers of that machine plus values of memory at all locations. In our case,
we have multiple machines. A naive approach to write down the state of all VMs
is to record their states respectively. While we only do it to registers and
combine their memory together as a global memory. The global here means one VM
could be able to access memory of another VM(in the case of memory sharing).

The definition of $\MEM$ is straightforward. While the $\STATE$ consists of not
only registers, but also some $\PID$s. The list of $\PID$ notes $\PID$s of all
pages that one VM owns, which is in principle determined by the stage-2 page
table of that VM. One may notice that there are two special $\PID$s that are not
included in the list. They are considered as RX/TX buffers for message passing.
The size of those two buffers are exactly one page, which is consistent to the
implementation of Hafnium. The reason that they are embraced by an $option$ is
that the two pages are uninitialized. There is a FF-A call through which a VM
can assign two pages it owns as its RX and TX pages. Afterwards, the RX/TX pages
are not strictly possessed by the VM anymore. In addition, VM is not able to
reassign other pages as RX/TX pages, i.e. RX/TX pages of a VM can only be
configured once.

It is worth to note that the $\mathtt{NZCV}$ is a system register, which means one
is only able to access to this register if it is in a high enough Exception Level. This register
is crucial to comparing and jumping instructions.
%details in : https://developer.arm.com/docs/ddi0595/h/aarch64-system-registers/nzcv

To explain why we defined the $\SSS$, we need to elaborate how memory sharing is
specified in the FF-A framework, which we won't do until next section when we
show the instructions. For now, it is enough for readers to know that $\PID$ is
the page to share, $\VMID$ the receiver of the sharing, and both are essential
to perform memory sharing. In Hafnium implementation, there is a similar but
much more complicated data structure to record those information(and more),
which is maintained by the Hafnium itself. Since we don't have the hypervisor in
our model, we added $\SSS$ into the execution configuration.

Some constants are introduced to specify basic configurations of the model. In
the context of AArch64, $\PAMAX$ should be $2^{\PABITS} - 1$ where
$\PABITS = 48$, $\PWMAX = 2^{\PWBITS} -1$ where $\PWBITS = 64$, and
$\PPIDMAX = 2^{\PPIDBITS}-1$ where $\PPIDBITS = \PABITS - \PPBITS = 36$.
$\PVMMAX$ makes sure we only have finite number of VMs.





\subsection{Syntax and Instructions}
\begin{figure}[h!]
  \begin{align*}
    \mu &\in \MODE &\derived & \mathtt{ExecInstr} \; v | \mathtt{Repeat} \; \mu | \mathtt{Done} \; \theta \\
    \theta &\in \DONE &\derived & \NXT{v} | \mathtt{Halt} | \mathtt{Fail}\\
    \\
    instr & \in  \INSTR &\derived & \instrm{br} \; r |\instrm{bne} \; r \; r |
                                    \instrm{mov} \; r \; w | \instrm{ldr} \; r\; r|
                                    \instrm{str} \; r \; r | \instrm{add} \; r \; r \; r |
                                    \instrm{sub} \; r \; r \; r | \instrm{cmp} \; r \; r \\
        & & & | \instrm{fail} | \instrm{halt} | \instrm{memd} \; r \; r | \instrm{memr} \; r\; r
  \end{align*}
  \caption{Syntax and Machine Instructions}
\end{figure}
\todo{later: add message passing instructions}

\todo{why we use set to define page tables?}
% Normally, page tables essentially are mappings. However, we instead use a
% mathematical set of $\PID$ to describe the abstract page table of a VM. We
% argue that it is sufficient to record necessary information of the actual
% page table as the $\PID$ in IP address space is always equal to the
% corresponding one in physical address space. Namely, we always have mappings
% like $x \mapsto x$ in page tables.
\todo{explain how did we omit memory translation} blabla



\subsection{Reduction rules}
\subsubsection{Notations}
Except claiming explicitly, we use triple $(\Delta, m, s)$ to represent
execution configuration $\phi$, where $\Delta$ is a list of $\STATE$. We notate
the $\STATE$ of VM $i$ in $\Delta$ with $\Delta[i]$. Furthermore, we use the
field access notation to represent the list of $\PID$ as $\Delta[i].ps$ and
$\REGS$ as $\Delta[i].rs$ respectively. We overload the square bracket notation
for the $\REGS$ and $\MEM$ mapping. Occasionally, we borrow the $\in, \cup,$ and
$\cap$ operators from set, applying them on the list while keeping the semantics
same.

\todo{to be rephrased}
% In addition, mappings are treated as functions so that they have concepts of
% domain and codomain.

\subsubsection{Rules}
\begin{figure}[h!]
  \begin{mathpar}
    \inferrule[RepeatExec]
    {(\EI{v},\, \phi) \rightarrow (\DN{\theta} ,\, \phi')}
    {(\RP{\EI{v}} ,\, \phi) \rightarrow (\RP{\DN{\theta}} ,\, \phi')}
    \and \inferrule[RepeatHalt/Fail]
    {\theta = \mathtt{Halt} \lor \theta = \mathtt{Fail}}
    {(\RP{\DN{\theta}} ,\, \phi) \rightarrow (\DN{\theta} ,\, \phi)}
    \and \inferrule[RepeatNext]{}
    {(\RP{\DN{\NXT{v}}} ,\, \phi) \rightarrow (\RP{\EI{v}} ,\, \phi)}
    \and \inferrule[ExecInstr]{}
    {{(\EI{v},\, \phi) \rightarrow \left\{
          \begin{array}{ll}
            \sem{\decode(iw)}(\phi,v)
               & \mathrm{if} \;\SOME(ia) = \valida(\Delta[v], \mathtt{pc}) \land m[ia]=iw \\
            (\DN{\mathtt{Fail}},\, \phi) & \mathrm{otherwise}
          \end{array} \right.}
    }
    \and
    \begin{aligned}
      \valida(\delta,r) &=\left\{  \begin{array}{ll}
                                     \SOME(ia) & \text{if} \; ia = \delta.rs[r] \land \pid(ia) \in \delta.ps \\
                                     \NONE & \text{otherwise}
                                   \end{array}
                                   \right. \\
      \pid(a) &= a >> \PPBITS
    \end{aligned}
  \end{mathpar}
  \caption{Reduction Steps.}
  % \vspace{-0.5cm}
\end{figure}

The \refr{RepeatExec} rule combined with the \refr{RepeatNext} and \refr{RepeatHalt/Fail}
rules are applied to proceed the execution. There are two major reasons on
why we didn't use instructions as expressions.
On one hand, instructions are related to the execution configuration,
their encoding are stored in the memory. However, we want something independent
to the configuration as expressions so that we can write down the rules in a more elegant way.
On the other hand, the $\mathtt{Repeat}$ acts like a context.
Therefore it is more straightforward and natural to come up with
the bind rule in the program logic, comparing to a sequence of instructions.

In \refr{ExecInstr}, the input of the $\decode$ function is a $\WORD$ $iw$ obtained from $\MEM$.
$\decode$ function decodes it to the corresponding $\INSTR$ which has a
predefined semantic interpretation. Applying the interpretation to execution
configuration $\phi$ and $\VMID$ v will give us a new configuration after
executing the instruction on VM $v$. If $iw$ is an invalid encoding, we decode
it to $\mathtt{fail}$.

To obtain the encoding of the next executing instruction $iw$, we first get the
value of the \texttt{pc} register of VM $v$ as $ia$, which is the address of the
$iw$ in the global memory. Before decoding $iw$, we have to ensure that VM $v$
has access to the location $ia$, i.e. $ia$ is in the range of a page that owned
by $v$. That is exactly what $\valida$ does. \todo{change description of valida}


\subsection{Semantic Interpretations of Instructions}

The last piece of the puzzle for operational semantic is the semantic interpretation
of instructions describing how to proceed on execution.

Regarding the modification of the $\STATE$, we use for instance $\Delta'$ to
implies it is modified, dinstinguishing from the original $\Delta$.
We prescibe that except what we state explicitly, the rest components of $\Delta'$ is identical to the corresponding components in $\Delta$. Informally, it is similar to first make a copy of the $\Delta$ as $\Delta'$, then do minor modification on $\Delta'$.

Note that all the register names in instructions below don't indicate actual registers.
For instance, $r_{1}$ donesn't have to be the $r_{1}$ register. They are just variables
whose values could be in principle names of any general registers.
\newcommand{\sema}[1]{\sem{ {#1} }(\phi,v)}
\newcommand{\leftshift}{\!\!\!\!\!\!\!}
\begin{figure}[h!]
  \[
\begin{array}{rlll}
  \sema{\instrm{fail}} &\leftshift = (\DN{\mathtt{Fail}}, \phi) & & \\
  \sema{\instrm{halt}} &\leftshift  = (\DN{\mathtt{Halt}}, \phi) & & \\
  \sema{\instrm{jmp} \; r} &\leftshift = (\DN{\NXT{v}},(\Delta',m,s)\:) & \Delta'[v].rs[\mathtt{pc}]=w & w= \Delta[v].rs[r]\\
  \sema{\instrm{jnz} \; r_{1} \; r_{2}} &\leftshift = (\DN{\NXT{v}}, (\Delta',m,s)\:) & \Delta'[v].rs[\mathtt{pc}]=w & w = \left\{
                                                          \!\!\!\!\begin{array}{ll} \Delta[v].rs[r_{1}] &\!\!\!\! \text{if} \;
                                                                                                    \Delta[v].rs[r_{2}]=0 \\
                                                            \Delta[v].rs[\mathtt{pc}]+1 &\!\!\!\! \text{otherwise}
                                                          \end{array}\right. \\

  \sema{\instrm{mov}\; r\; w} &\leftshift = (\DN{\NXT{v}}, \updpc((\Delta', m, s), v))\:) & \Delta'[v].rs[r]=w & \\
  \sema{\instrm{ldr}\; r_{1} \; r_{2}} &\leftshift = (\DN{\NXT{v}}, \updpc((\Delta', m, s), v))\:) & \Delta'[v].rs[r_{1}]=w &
                                                           \text{if}\; \begin{array}{l} \SOME(a)=\valida(\Delta[v],r_{2})\\
                                                                         \land w = m[a]
                                                                       \end{array}\\
  \sema{\instrm{str}\; r_{1} \; r_{2}} &\leftshift = (\DN{\NXT{v}},\updpc((\Delta, m', s),v))\:) & m'[a]=w &
                                                            \text{if}\; \begin{array}{l} \SOME(a) =\valida(\Delta[v],r_{1})\\
                                                                          \land w = \Delta[v].rs[r_{2}]
                                                                        \end{array}\\
  \sema{\instrm{add}\; r_{1}\; r_{2}\; r_{3}} &\leftshift = (\DN{\NXT{v}}, \updpc((\Delta', m, s), v))\:) & \Delta'[v].rs[r_{1}]=w & w=\Delta[v].regs[r_{2}] + \Delta[v].regs[r_{3}] \\
  \sema{\instrm{sub}\; r_{1}\; r_{2}\; r_{3}} &\leftshift =(\DN{\NXT{v}}, \updpc((\Delta', m, s), v))\:) & \Delta'[v].rs[r_{1}]=w & w=\Delta[v].regs[r_{2}] - \Delta[v].regs[r_{3}] \\
  \sema{\instrm{lt}\; r_{1}\; r_{2}\; r_{3}} &\leftshift = (\DN{\NXT{v}}, \updpc((\Delta', m, s), v))\:) & \Delta'[v].rs[r_{3}]=w & \\
  \sema{\instrm{lea}\; r_{1}\; r_{2}\; r_{3}} &\leftshift = (\DN{\NXT{v}}, \updpc((\Delta', m, s), v))\:) & \Delta'[v].rs[r_{3}]=w & \\
  \sema{\instrm{memd}\; r_{1}\; r_{2}} &\leftshift = & & \\
  \sema{\instrm{memr}\; r_{1}\; r_{2}} &\leftshift = & & \\
\end{array}
\]
\end{figure}
\todo{later: consider overflow}
\section{Proof Rules}

\end{document}
