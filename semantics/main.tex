\documentclass[a4paper]{article}
\usepackage[a4paper,tmargin=0.75in,bmargin=1in,showframe=false]{geometry}
\usepackage{multicol,multirow}
\usepackage{amsmath}
\usepackage{mathpartir}
\usepackage{hyperref}
\usepackage{todonotes}
\usepackage{graphicx}
\usepackage{kpfonts}
\usepackage{array}
\usepackage{changepage}
\usepackage[T1]{fontenc}

\newcolumntype{L}{>{$}l<{$}}

% notations
\newcommand*{\defined}{\triangleq}
\newcommand*{\maps}{\rightarrow}
\newcommand*{\derived}{::=}
\newcommand*{\sem}[1]{\llbracket {#1} \rrbracket}
\newcommand*{\append}{\scalebox{0.8}{+\kern-0.4ex+}}


% definitions
\newcommand*{\CONF}{\text{ExecConf}}
\newcommand*{\STATE}{\text{State}}
\newcommand*{\MEM}{\text{GlobalMem}}
\newcommand*{\SSS}{\text{ShareStates}}
\newcommand*{\PID}{\text{PID}}
\newcommand*{\REGS}{\text{Registers}}
\newcommand*{\ADDR}{\text{Address}}
\newcommand*{\WORD}{\text{Word}}
\newcommand*{\VMID}{\text{VMID}}
\newcommand*{\REGNAMES}{\text{RegisterName}}
\newcommand*{\MODE}{\text{ExecMode}}
\newcommand*{\DONE}{\text{DoneState}}
\newcommand*{\INSTR}{\text{Instruction}}
\newcommand*{\MB}{\text{MailBox}}
\newcommand*{\TIMER}{\text{Timer}}

% parameters
\newcommand*{\PABITS}{\text{ADDR\_BITS}}
\newcommand*{\PPBITS}{\text{PAGE\_BITS}}
\newcommand*{\PPIDBITS}{\text{PID\_BITS}}
\newcommand*{\PAMAX}{\text{ADDR\_MAX}}
\newcommand*{\PPMAX}{\text{PAGE\_MAX}}
\newcommand*{\PPIDMAX}{\text{PID\_MAX}}
\newcommand*{\PWBITS}{\text{WORD\_BITS}}
\newcommand*{\PWMAX}{\text{WORD\_MAX}}
\newcommand*{\PVMMAX}{\text{VM\_MAX}}

% FFA functions
\newcommand*{\INT}{\text{INTERRUPT}}
\newcommand*{\MSGS}{\text{MSG\_SEND}}
\newcommand*{\MSGW}{\text{MSG\_WAIT}}
\newcommand*{\YIELD}{\text{YIELD}}
\newcommand*{\BUSY}{\text{BUSY}}
\newcommand*{\SUCC}{\text{SUCCESS}}
% instructions
\newcommand*{\instrm}[1]{\mathtt{#1}}
\newcommand*{\instr}[1]{\texttt{#1}}

% TODO: message passing instructions

% expressions
\newcommand*{\EI}[1]{\mathtt{ExecInstr} \; {#1}}
\newcommand*{\RP}[1]{\mathtt{Repeat} \; {#1}}
\newcommand*{\DN}[1]{\mathtt{Done} \; {#1}}
\newcommand*{\NXT}[1]{\mathtt{Next} \; {#1}}

% functions
\newcommand*{\decode}{\text{decode}}
\newcommand*{\valida}{\text{valida}}
\newcommand*{\updpc}{\text{updpc}}
\newcommand*{\pid}{\text{pid}}


% reference
\renewcommand{\DefTirName}[1]{\hypertarget{#1}{\TirName {#1}}}
\newcommand{\refr}[1]{\hyperlink{#1}{\TirName {#1}}}

% SOME/NONE
\newcommand{\SOME}{\mathtt{Some}}
\newcommand{\NONE}{\mathtt{None}}

\title{Operational Semantics % and Proof Rules
  for VMs in Hafnium} \date{\today}
\author{Zongyuan Liu}

\begin{document}
\maketitle

\section{Operational Semantics}

\todo{later: more realistic scheduling}
\subsection{Setting of Hafnium}
Hafnium is a type-1 hypervisor running on the AArch64 architecture(for now),
which is claimed can provide memory isolation between a set of virtual
machines(VMs) running on it. Hafnium provides memory isolation by managing the
stage-2 page tables of VMs. It controls the stage-2 translation by manipulating
entries in stage-2 page tables only according to the FF-A calls issued by VMs.
The hardware does the actual address translation by looking up page table
entries, which we assume working correctly. Therefore Hafnium can
guarantee that one VM can never access to the memory owned by another VM without
that VM's consent.

For the sake of simplicity, stage-2 page tables managed by the Hafnium are
simply one-to-one mappings, i.e. the IPAs are always equal to PAs. Besides, it
is also the case for the stage-1 page table of the Hafnium itself.

FF-A framework is designed as a protocol for components running on the ARM-A
processor, the main purpose of which is to allow components in the normal world
to communicate with components in the secure world. While in Hafnium, VMs and
the hypervisor are all counted as components residing in the normal world. The
FF-A framework serves as an approach for VMs to do message passing and
memory sharing with each other. We will see some examples of how exactly the
FF-A framework is utilized in Hafnium later.

One can read more details on the Hafnium architecture
\href{https://review.trustedfirmware.org/plugins/gitiles/hafnium/hafnium/+/HEAD/docs/Architecture.md}{here}.

\subsection{Execution Configuration}
\todo{later: improve error handling} The general purpose of the operational
semantics is to reason about programs written in assembly language running on
VMs. Therefore, in our operational semantics, we abstract away the Hafnium
hypervisor, considering the whole system only consists of several virtual
machines plus some additional information for the FF-A framework.

\begin{figure}
  \begin{align*}
    \phi &\in \CONF &\defined &list(\STATE) \times \MEM \times \SSS \\
    \delta &\in \STATE &\defined &list(\PID) \times \REGS \times \TIMER  \times \MB \\
    \pi & \in \MB &\defined &option(\PID) \times option(\PID \times \text{Bool} \times \WORD \times \VMID) \\
    t & \in \TIMER &\defined & \WORD \\
    p & \in \PID &\defined  &[ 0, \PPIDMAX ] \\
    r & \in \REGS &\defined  &\REGNAMES \maps \WORD \\
    n & \in \REGNAMES &\derived  &\mathtt{pc} | \mathtt{NZ} | \mathtt {R0} | \mathtt{R1} | \dots \\
    m & \in \MEM &\defined  &\ADDR \maps \WORD \\
    a & \in \ADDR &\defined  &[ 0, \PAMAX ] \\
    w & \in \WORD &\defined  &[ 0, \PWMAX ] \\
    s & \in \SSS &\defined  &list(\PID \times \VMID) \\
    v & \in \VMID &\defined  &[ 0, \PVMMAX ]
  \end{align*}
  \caption{Execution Configuration: VM States, Global Memory, and Share States.}
\end{figure}
\todo{write list($\PID$) and option($\PID$) separately}
Figure 1 shows the definition of execution configuration, which includes three
components: $\STATE$s of all VMs, a $\MEM$ shared with all VMs, and a $\SSS$
storing necessary information for memory sharing FF-A requests.

Normally, the state of a machine includes values of all
registers of that machine plus values of memory at all locations. In our case,
we have multiple machines. A naive approach to write down the state of all VMs
is to record their states separately. However, we only apply it to registers and
combine their memory together as a global memory. The global here means one VM
could be able to access memory of another VM(in the case of memory sharing).

The definition of $\MEM$ is straightforward. While the $\STATE$ consists of not
only registers, but also some $\PID$s.
%\todo{Lars: shouldn't there be some condition expressing that the memory mapped
%  by pages belonging to different VMs do not overlap ?}
The list of $\PID$ notes $\PID$s of all
pages that one VM owns, which is in principle determined by the stage-2 page
table of that VM.
Somehow, the memory isolation property might be able to be derived
by looking at the disjointness among these lists. Namely, if none of $\PID$s is in
lists of two VMs, we may argue that their memory are isolated from each other.
But, one should be careful to say it if there are any memory sharings, where the $\PID$
of the shared page will appear in two lists. Fortunately, it is feasible to tell
whether any memory sharing is happening by looking at the $\SSS$, which is responsible
for tracking all memory sharing operations.

Despite page tables essentially are maps, we instead use a mathematical list of
$\PID$s as the abstract page table of a VM.
% \todo{Lars: I don't understand this para}
We argue it is sufficient to record all the necessary translation
information in the actual page table. Because in Hafnium, a $\PID$ in IP address
space is always equal to the corresponding one in the physical address space.
\todo{add a drawing}
Namely, we always have mappings like $x \mapsto x$ in stage-2 page tables.
Another benefit of this mapping scheme is that we can omit stage-2 translation entirely.

One may notice that there are two special $\PID$s that are not included in the
list. They are considered as RX/TX buffers for message passing. The size of
those two buffers is exactly one page, which is consistent to the
implementation of Hafnium. The reason that they are embraced by an $option$ is
that the two pages are uninitialized. There is a FF-A call through which a VM
can assign two pages it owns as its RX and TX pages. Afterwards, the RX/TX pages
are not strictly possessed by the VM anymore. In addition, VM is no longer able to
reassign other pages as new RX/TX pages, i.e. RX/TX pages of a VM can only be
configured once. \todo{comment on new mailbox}

It is worth to note that the $\mathtt{NZ}$ is a system register, which means one
is only able to access to this register if it is at a high enough Exception
Level. This register is crucial to comparing and jumping instructions. It has
similar functionality as the
\href{https://developer.arm.com/docs/ddi0595/h/aarch64-system-registers/nzcv}
{$\mathtt{NZCV}$ register} in real Arm-A processors.

To explain why we defined the $\SSS$, we need to elaborate on how memory sharing is
specified in the FF-A framework, which we won't do until Section 1.5 when we
show semantics of instructions. For now, it is enough for readers to know that $\PID$ is
the page to share, $\VMID$ the receiver of the sharing, and both are essential
to perform memory sharing. In Hafnium implementation, there is a similar but
much more complicated data structure to record those information(and more),
which is maintained by the Hafnium itself. Since we don't have the hypervisor in
our model, we added $\SSS$ into the execution configuration.

Some constants are introduced as well to specify basic configurations of the model. In
the context of AArch64, $\PAMAX$ should be $2^{\PABITS} - 1$ where
$\PABITS = 48$, $\PWMAX = 2^{\PWBITS} -1$ where $\PWBITS = 64$, and
$\PPIDMAX = 2^{\PPIDBITS}-1$ where $\PPIDBITS = \PABITS - \PPBITS = 36$.
$\PVMMAX$ makes sure we only have finite number of VMs.


\subsection{Syntax and Instructions}
\begin{figure}[h!]
  \begin{align*}
    \mu &\in \MODE &\derived & \mathtt{ExecInstr} \; v | \mathtt{Repeat} \; \mu | \mathtt{Done} \; \theta \\
    \theta &\in \DONE &\derived & \NXT{v} | \mathtt{Halt} | \mathtt{Fail}\\
    \\
    instr & \in  \INSTR &\derived & \instrm{br} \; r |\instrm{bne} \; r \; r |
                                    \instrm{mov} \; r \; w | \instrm{ldr} \; r\; r|
                                    \instrm{str} \; r \; r | \instrm{add} \; r \; r \; r |
                                    \instrm{sub} \; r \; r \; r | \instrm{cmp} \; r \; r \\
        & & & | \instrm{fail} | \instrm{halt} | \instrm{hvc}
              %\instrm{memd} \; r \; r | \instrm{memr} \; r\; r | \instrm{run} \; r|
              %\instrm{yld} | \instrm{msgw} | \instrm{msgs} \; r_1 \; r_{2} | \instrm{msgr}
  \end{align*}
  \caption{Syntax and Machine Instructions}
\end{figure}
\todo{later: change new instructions back to hvc}
The syntax and instructions included in our model are shown in Figure 2. The
syntax of the expression is uncomplicated. Generally speaking, $\EI{v}$ is for
executing a single instruction in VM $v$ and $\DN{\theta}$ implies the result of
the execution. The result could be successful or failed. In case of success, we
either proceed on the next instruction in VM $v$ with $\NXT{v}$ or halt.

There are two major reasons why we didn't use instructions as expressions. On
one hand,
instructions are related to the execution configuration, their encodings are
stored in the memory. However, we want something independent of the
configuration as expressions so that we can write down the rules in a more
elegant way. On the other hand, $\mathtt{Repeat}$ acts like a context.
Therefore it is more straightforward and natural to come up with the bind rule
in the program logic, comparing to a sequence of instructions.


We included a subset of AArch64 instructions and believe that these instructions
are sufficient to construct interesting programs. Besides, it would be
effortless to include new instructions. All we need to do is adding the
instruction and giving a semantic interpretation. One minor thing to mention is
that we assume addresses in instructions are IPAs, i.e. they have undergone
stage-1 translation. Even though it makes our model slightly unrealistic, we argue
that it is totally acceptable since our main target is stage-2 memory access.

\subsubsection{\instr{hvc} Instruction}
In reality, all sorts of communications
between VMs are indirect in Hafnium system(done through FF-A function calls).
Namely, the hypervisor involves in. For instance, for memory donation, page
tables need to be modified while only the hypervisor has high enough Exception
Level and access to the memory where page tables are stored. The instruction
\texttt{hvc} would be executed with some arguments by the VM to raise the
Exception Level and invoke the hypervisor to do the actual work. It more or less
acts like a system call in OS.
% However, since our program language for VMs is
% assembly and the implementations of FF-A functions are written in C, we choose
% not to implement FF-A functions in assembly language but introduce new
% instructions with appropriate semantics describing what these functions do.
% There are currently two instructions for memory sharing, among that
% \texttt{memd} is for donating a page, and \texttt{memr} is for retrieving a
% page. We will talk about their semantics later.



\todo{later:initial state?}

\subsection{Reduction rules}
\subsubsection{Notations}
An execution configuration $\phi$ is a triple, where $\phi.\Delta$
is a list of $\STATE$,$\phi.m$ the global memory, and $\phi.s$ the $\SSS$. $\Delta[i]$ is used
to notate the $\STATE$ of VM $i$ in $\Delta$. Furthermore, we utilize the field
access notation to express the list of $\PID$ as $\Delta[i].ps$, the RX buffer as $\Delta[i].\pi_{r}$,
and the TX buffer as $\Delta[i].\pi_{t}$.
We overload the square bracket notation to access
the value corresponding to a given key in $\REGS$ and $\MEM$ mappings. Occasionally, we
borrow $\in$ and $\setminus$ operators from sets, applying on lists. We still require
the property that elements are ordered sometimes, therefore these
operators might only be considered as operators for finding
and removing elements from a list respectively.

%\todo{Lars: later we should check if/when we rely on the lists being ordered}

% In addition, mappings are treated as functions so that they have
% domain and codomain.

\subsubsection{Rules}


\begin{figure}[h!]
  \begin{mathpar}
    \inferrule[RepeatExec] {(\EI{v},\, \phi) \rightarrow (\DN{\theta} ,\,
      \phi')} {(\RP{\EI{v}} ,\, \phi) \rightarrow (\RP{\DN{\theta}} ,\, \phi')}
    \and \inferrule[RepeatHalt/Fail] {\theta = \mathtt{Halt} \lor \theta =
      \mathtt{Fail}} {(\RP{\DN{\theta}} ,\, \phi) \rightarrow (\DN{\theta} ,\,
      \phi)} \and \inferrule[RepeatNext]{} {(\RP{\DN{\NXT{v}}} ,\, \phi)
      \rightarrow (\RP{\EI{v}} ,\, \phi)} \and \inferrule[ExecInstr]{}
    {{(\EI{v},\, \phi) \rightarrow \left\{
          \begin{array}{ll}
            \sem{\decode(w_i)}(\phi.\Delta, \phi.m, \phi.s ,v)
            & \mathrm{if} \;\SOME(a_i) = \valida(\phi.\Delta[v], \mathtt{pc},V) \land m[a_i]=w_i \\
            (\DN{\mathtt{Fail}},\, \phi) & \mathrm{otherwise}
          \end{array} \right.}
    }
    \and
    \begin{aligned}
      \valida(\delta,r,P) &=\left\{ \begin{array}{ll}
                                      \SOME(a_i) & \text{if} \; a_i = \delta.r[r] \\
                                                 &\land \big( (P=V \land \pid(a_i) \in \delta.ps) \\
                                                 &\lor (P=R \land (\pid(a_i)\in \delta.ps \lor \SOME(\pid(a_i),-,-,-)=\delta.\pi_r)) \\
                                                 &\lor (P=W \land (\pid(a_i)\in \delta.ps \lor \SOME(\pid(a_i))=\delta.\pi_t))\big) \\
                                    \NONE & \text{otherwise}
                                  \end{array}
                                \right. \\
      \pid(a) &= a >> \PPBITS
    \end{aligned}
  \end{mathpar}
  \caption{Reduction Steps.}
  % \vspace{-0.5cm}
\end{figure}

In Figure 3, the \refr{RepeatExec} rule combined with the \refr{RepeatNext} and
\refr{RepeatHalt/Fail} rules are applied to proceed with the execution.

In \refr{ExecInstr}, the input of the $\decode$ function is a $\WORD$ $w_{i}$(for instruction word)
obtained from $\MEM$. The $\decode$ function decodes it to the corresponding
$\INSTR$ which has a predefined semantic interpretation.
%\todo{Lars: in that rule, is $m$ the global memory ? It should be a parameter somehow to the rule, I guess}
Applying the interpretation to execution configuration $\phi$ and $\VMID$ v will give us a
new configuration after executing the instruction on VM $v$. If $w_{i}$ is an
invalid encoding, we decode it as $\mathtt{fail}$.
%\todo{Lars: a detail: using $iw$ and $ia$ as variables is a little confusing}

To obtain the encoding of the next executing instruction $w_{i}$, we first get the
value of the \texttt{pc} register of VM $v$ as $w_{i}$, which is the address of the
$w_{i}$ in the global memory. Before decoding $w_{i}$, we have to ensure that the
memory access is valid, i.e., $a_{i}$ is in the range of a page owned by $v$.
The validation is done by $\valida$ function.


\subsection{Semantic Interpretations of Instructions}

The last piece of the puzzle of operational semantic
is the semantic interpretations of instructions describing how to proceed on
execution, which is shown in Figure 4.

The semantics interpretations of AArch64 instructions are generally
trivial. The only worth-mentioned point is the conditions of \instr{ldr} and
\instr{str}. The validity of the target memory accessing address has to be
checked to guarantee the memory isolation property. Note we give different last arguments in $\valida$.
$R$ indicates it is a read operation, therefore it is allowed to let the RX buffer be
the location to be read. Similarly, the TX buffer could be the location of write operations.


\subsubsection{Notations}
Regarding the modification of the $\STATE$, we use for instance $\Delta'$ to
implies it is modified, distinguishing from the original $\Delta$. Excepting
what we state explicitly, the rest components of $\Delta'$ are identical to the
counterparts in $\Delta$. Informally, one can understand it as we first make a
copy of the $\Delta$ as $\Delta'$, then do some minor modifications on
$\Delta'$.

Note that we only use $\mathtt{mathtt}$ font to represent actual registers.
While the regular \emph{Italic} font is used for any general registers. For
instance, $r_{1}$ doesn't have to be the $\mathtt{R1}$ register.

\newcommand{\reg}[1]{\texttt{{#1}}}

\subsubsection{\instr{hvc} Calling Conventions}
All FF-A calls are implemented as synchronous exceptions, since they need higher EL to complete. The \instr{hvc} instruction is used to generate such exceptions that will be handled by the hypervisor. In \href{https://developer.arm.com/documentation/den0028/latest}{this} document, calling conventions of hvc calls are specified, which are complied with by FF-A calls as well. Readers will see we followed the conventions in the semantic interpretation of \instr{hvc}.

%Most of FF-A calls are so-called fast call, which means these calls executions that are atomic from the view of VMs.

A FF-A call contains a function identifier determining the function to be invoked, several arguments, and the return. All of these components are stored in registers. In AArch64, \reg{R0}-\reg{R7} registers are used. In particular, \reg{W0} identified as the least significant 32-bits of \reg{R0} has the role of function identifier in FF-A calls. Furthermore, \reg{W1}-\reg{W6} works as parameter registers, which implies FF-A can have at maxinum six arguments. For return value, \reg{W0}-\reg{W3} are used. Error Codes are returned in \reg{W0}.




\newcommand{\sema}[1]{\sem{ {#1} }(\Delta,m,s,v)}
\newcommand{\llen}[1]{\text{len}( {#1})}
\newcommand{\leftshift}{\!\!\!\!}
\newcommand{\DNXT}[2]{(\DN{\NXT{ {#1} }}, {#2})}
\newcommand{\nextt}{\text{tick}}
% \newcommand{\toword}[1]{\text{toWRD}(\text{{#1}})}
\newcommand{\toword}[1]{\text{{#1}}}
\begin{figure}[h!]
  \begin{adjustwidth}{-1cm}{}
    \begin{tabular}[t]{|l|L L|l|l|}
      \hline
      Instr$(i)$ &\sema{i} & \text{where} &  \multicolumn{2}{l|}{Conditions} \\ \hline \hline
      \instr{fail}&\leftshift (\DN{\mathtt{Fail}}, (\Delta,m,s)) & & \multicolumn{2}{l|}{} \\ \hline
      \instr{halt}&\leftshift (\DN{\mathtt{Halt}}, (\Delta,m,s)) & & \multicolumn{2}{l|}{} \\\hline
      \instr{br} $r$&\leftshift \nextt(\Delta',m,s,\text{id},v,v)  & \Delta'[v].r[\mathtt{pc}]=\Delta[v].r[r] & \multicolumn{2}{l|}{} \\\hline
      \multirow{2}{*}{\instr{bne} $r$}&\multirow{2}{*}{$\leftshift \nextt(\Delta',m,s,\text{id},v,v)$}
                               & \Delta'[v].r[\mathtt{pc}]= \Delta[v].r[r] & \multicolumn{2}{l|}{$\Delta[v].r[\mathtt{NZ}].z=1$} \\\cline{3-5}
                               & & \Delta'[v].r[\mathtt{pc}]= \Delta[v].r[\mathtt{pc}]+1 &\multicolumn{2}{l|}{otherwise} \\\hline
      \instr{mov} $r$ $w$&\leftshift \nextt(\Delta', m, s,\updpc,v,v)  & \Delta'[v].r[r]=w & \multicolumn{2}{l|}{} \\\hline
      \instr{ldr} $r_{1}$ $r_{2}$&\leftshift \nextt(\Delta', m, s,\updpc,v,v) & \Delta'[v].r[r_{1}]=m[a]  &
                                \multicolumn{2}{l|}{$\SOME(a)=\valida(\Delta[v],r_{2},R)$} \\\hline
      \instr{str} $r_{1}$ $r_{2}$&\leftshift \nextt(\Delta', m, s,\updpc,v,v) & m'[a]=\Delta[v].r[r_{2}]&
                                \multicolumn{2}{l|}{$\SOME(a) =\valida(\Delta[v],r_{1},W)$} \\\hline
      \instr{add} $r_{1}$ $r_{2}$ $r_{3}$&\leftshift \nextt(\Delta', m, s,\updpc,v,v) &\leftshift \begin{array}{l}\Delta'[v].r[r_{1}]= \Delta[v].r[r_{2}] + \Delta[v].r[r_{3}] \end{array} & \multicolumn{2}{l|}{} \\\hline
      \instr{sub} $r_{1}$ $r_{2}$ $r_{3}$&\leftshift \nextt(\Delta', m, s,\updpc,v,v) &\leftshift \begin{array}{l}\Delta'[v].r[r_{1}]= \Delta[v].r[r_{2}] - \Delta[v].r[r_{3}] \end{array} & \multicolumn{2}{l|}{} \\\hline
      \multirow{4}{*}{\instr{cmp} $r_{1}$ $r_{2}$}&\multirow{4}{*}{$\leftshift \nextt(\Delta', m, s,\updpc,v,v)$}
                                 & w = \Delta[v].r[r_{1}] - \Delta[v].r[r_{2}] & \multicolumn{2}{l|}{} \\\cline{3-4}
                                 & & \Delta'[v].r[\mathtt{NZ}]= 1 & $w = 0$ & \\\cline{3-4}
                                 & & \Delta'[v].r[\mathtt{NZ}]= 2 & $w < 0$ & \\\cline{3-4}
                                 & & \Delta'[v].r[\mathtt{NZ}]= 0 & otherwise &\\\hline
      \multirow{33}{*}{\instr{hvc}}&\leftshift \nextt(\Delta', m, s',\updpc,v,v)
                                    &\!\!\!\!\! \begin{array}{l}
                                               \Delta'[v].ps=\Delta[v].ps \setminus \{\pid(a_p)\}  \\
                                               v_r =  \Delta[v].r[\mathtt{R2}] \\
                                               s' = s \append [(\pid(a_p), v_r)]\\
                                               \Delta'[v].r[\mathtt{R2}]=\llen{s'}\\
                                               \Delta'[v].r[\mathtt{R0}]=\toword{SUCCESS}
                                             \end{array}
                                    & \multicolumn{2}{l|}{$\leftshift\begin{array}{l}
                                                    \Delta[v].r[\mathtt{R0}]=\toword{MEM\_DNT}\\
                                                    \SOME(a_p)=\valida(\Delta[v],\mathtt{R1},V) \\
                                                    v_r < \llen{\Delta}\\
                                                    v \neq v_r
                                                  \end{array}$}\\\cline{2-5}
      &\leftshift \nextt(\Delta', m, s',\updpc,v,v)
                           &\!\!\!\!\! \begin{array}{l}
                                         \Delta'[v].ps=\Delta[v].ps \append [p]\\
                                         s'= s \setminus \{(p,v)\}\\
                                         \Delta'[v].r[\mathtt{R0}]=\toword{MEM\_RTRVP}
                                       \end{array}
                 &\multicolumn{2}{l|}{$\leftshift\begin{array}{l}
                                                   \Delta[v].r[\mathtt{R0}]=\toword{MEM\_RTRVQ}\\
                                                   s[\Delta[v].r[\mathtt{R1}]] = (p, v)\\
                                                   p \notin \Delta[v].ps
                                 \end{array}$} \\\cline{2-5}
      & \multirow{5}{*}{$\leftshift \nextt(\Delta', m, s,\updpc,v, v_n)$}
                                      & v_n=\Delta[v].r[\mathtt{R1}]
                                          & \multicolumn{2}{l|}{\multirow{2}{*}{$\leftshift \begin{array}{l}
                                                                                              \Delta[v].r[\mathtt{R0}]=\toword{RUN}\\
                                                                                              v=0 \land v_n < \llen{\Delta}
                                                                                              \end{array}$}}\\
                                 & &\SOME(p_r,b,w_s,v_s)=\Delta[v_n].\pi &\multicolumn{2}{l|}{\multirow{2}{*}{}}\\\cline{3-4}
                                 & &\!\!\!\!\!\begin{array}{l}
                                              \Delta'[v_n].r[\mathtt{R0}]=\toword{MSG\_SEND}\\
                                              \Delta'[v_n].r[\mathtt{R1}]=\text{comb}(v_s,v_n)\\
                                              \Delta'[v_n].r[\mathtt{R3}]=w_s
                                                        \end{array}& $b$ & \\\cline{2-5}
      & \leftshift \nextt(\Delta', m, s,\updpc, v, 0)
                                 &\!\!\!\!\! \begin{array}{l}
                                               \Delta'[0].r[\mathtt{R0}]=\toword{\YIELD}\\
                                               \Delta'[0].r[\mathtt{R1}]=v
                                               \end{array}& \multicolumn{2}{l|}{$\Delta[v].r[\mathtt{R0}]=\toword{YIELD}$} \\\cline{2-5}
      \multirow{8}{*}{}&\multirow{8}{*}{$\leftshift \nextt(\Delta', m, s,\updpc, v, v_n)$}
                                 & \SOME(p_r,b,w_s,v_s)=\Delta[v].\pi_r& \multicolumn{2}{l|}{$\Delta[v].r[\mathtt{R0}]=\toword{MSG\_WAIT}$} \\\cline{3-4}
                                 & &\!\!\!\!\!\begin{array}{l}
                                              v_n=v\\
                                              \Delta'[v_n].r[\mathtt{R0}]=\toword{\MSGS}\\
                                              \Delta'[v_n].r[\mathtt{R1}]=v_s\\
                                              \Delta'[v_n].r[\mathtt{R3}]=w_s
                                              \end{array} & $b$&\\\cline{3-4}
                                 & &\!\!\!\!\!\begin{array}{l}
                                              v_n=0\\
                                              \Delta'[v_n].r[\mathtt{R0}]=\toword{\MSGW}\\
                                              \Delta'[v_n].r[\mathtt{R1}]=v
                                 \end{array}& $!b$& \\\cline{2-5}
      \multirow{11}{*}{}& \multirow{11}{*}{$\leftshift \nextt(\Delta', m', s,\updpc,v,v_n)$}
                           & v_r=\Delta[v].r[\mathtt{R1}]&\multicolumn{2}{l|}{\multirow{3}{*}{$\leftshift\begin{array}{l}
                                                                                                   \Delta[v].r[\mathtt{R0}]=\toword{MSG\_SEND}\\
                                                                                                   \Delta[v].\pi_{t}=\SOME(p_t)
                                                                                                   \end{array}$}} \\
                                 & & w_s=\Delta[v].r[\mathtt{R2}]& \multicolumn{2}{l|}{}\\
                                 & & \SOME(p_r,b,-,-)=\Delta[v_r].\pi& \multicolumn{2}{l|}{} \\\cline{3-4}
                                 & & \!\!\!\!\!\begin{array}{l}
                                                 v_n=0\\
                                                 \Delta'[v_r].\pi=\SOME(p_r,\mathtt{true},w_s,v)\\
                                                 m'=\text{memcpy}(m,p_t,p_r,w_s)\\
                                                 \Delta'[v].r[\mathtt{R0}]=\toword{\SUCC}\\
                                                 \Delta'[0].r[\mathtt{R0}]=\toword{\MSGS}\;\text{if}\;v\neq 0\\
                                                 \Delta'[0].r[\mathtt{R1}]=\text{comb}(v,p_r)\;\text{if}\;v\neq 0
                                               \end{array} & $!b$ &\\\cline{3-4}
                                & &\!\!\!\!\!\begin{array}{l}
                                               v_n=v\\
                                               \Delta'[v].r[\mathtt{R0}]=\toword{\BUSY}
                                             \end{array} & $b$&\\\cline{2-5}
      & \leftshift  \nextt(\Delta', m, s,\updpc, v, v_n)& \Delta'[v].\pi_r = \SOME(p_r,\mathtt{false},-,-)
                                          &\multicolumn{2}{l|}{$\leftshift \begin{array}{l}
                                                                             \Delta[v].r[\mathtt{R0}]=\toword{MSG\_RCV}\\
                                                                             \Delta[v].\pi_{r}=\SOME(p_r,\mathtt{true},-,-)
                                                                             \end{array}$} \\\hline
    \end{tabular}
  \end{adjustwidth}
  \caption{Instruction Semantics.}
\end{figure}
\todo{later: consider overflow}
\begin{figure}[!h]
  \begin{align*}
    \updpc(\Delta,m,s,v)&=(\Delta',m,s)\ \; \text{where}\; \Delta'[v].r[\mathtt{pc}] = \Delta[v].r[\mathtt{pc}]+1\\
    \text{id}(\Delta,m,s,v)& = (\Delta,m,s)\\
    \nextt(\Delta,m,s,f,v,n)&= \left\{\!\!\!\!\begin{array}{lll}
                                               \DNXT{n}{f(\Delta',m,s,v)} &\text{where } \Delta'[v].t = \Delta[v].t-1& \text{if}\: \Delta[v].t -1 \neq 0\\
                                               &\\
                                               \DNXT{0}{f(\Delta',m,s,v)} &\text{where } \!\!\!\! \begin{array}{l}
                                                                                      \Delta'[v].t = \Delta[v].t-1,\\
                                                                                      \Delta'[0].r[\mathtt{R0}]=\toword{INTERRUPT},\\
                                                                                      \Delta'[0].r[\mathtt{R1}] = v
                                                                                      \end{array}& \text{otherwise}
                                              \end{array}  \right.\\
    \text{comb}(w_{1},w_{2})&=w_{1}<<(\PWBITS/2)+w_{2}
  \end{align*}
  \caption{Instruction Semantics(Cont.).}
\end{figure}
\subsubsection{Memory Sharing}
As mentioned in Section 1.3, we introduced two newly invented instructions for
memory sharing between VMs. The $\instr{memd}\; r_{1}\; r_{2}$ is executed by
the donor(Sender) to donate a page with $\PID$ stored in the first register to
the recipient(Receiver) whose $\VMID$ is stored in the second register. However,
\instr{memd} merely does half of the donation. According to the specification of
the FF-A framework, it mainly does three things: 1. doing tons of checkings; 2.
removing the $\PID$ of the donated page from sender's page table and 3. keeping
donation details in the hypervisor(in $\SSS$) and returning a handle(an index).
If one reads the semantic interpretation of \instr{memd}, he will find out that
it follows the specification, accomplishing the three things as well, just in a
much simpler way(since our execution configuration is simplified). The second
half of the donation is completed by the receiver with \instr{memr}. Hypervisor
reads the information of the donation through the handle passed by the receiver,
then it does more checkings and adds the $\PID$ of the donated page into the
page table of the receiver. The difference between the implementation and our
instruction is that we remove the donation information from $\SSS$ while it is
kept and has further usages in the implementation.
\todo{elaborate it in detail}

\subsubsection{Message Passing and Scheduling}
\todo{a bit too concrete?}
We will elaborate message passing and scheduling together in this section as
these two are closely related. Loosely speaking, sending and waiting for
messages expect the scheduler to schedule a specific VM, usually either the
sender or the receiver, to run next. It is for getting the sender or the
receiver notified.

Let's talk about the less-complicated scheduling first. In Hafnium, the
scheduler resides in the primary VM which usually uses its thread scheduler as
the VM level scheduler. To achieve it, the primary VM allocates threads for all
VMs, and then schedule them as regular threads. However, to let the whole system
function correctly, several expectations are given to the primary VM scheduler
according to the FF-A specification. We will mention them when we meet.

Making use of primary VM's scheduler instead of writing a scheduler in the
hypervisor dramatically reduces the verification work of hypervisor. Although
the downside is we lose the availability guarantee of all secondary VMs.

To make the scheduling more realistic, we introduced a $\TIMER$ and a mechanism
working like the timer interrupt in our model. The $\TIMER$ countdowns by $1$
whenever executing an instruction. When it becomes zero, the current running VM
will be preempted, switching back to the primary VM(the VM with $\VMID$ 0), and
meanwhile, telling the primary VM who was running before the ''interrupt''(we
don't have actual interrupts) . These are done by the tick function. One may
notice that the telling part is carried out by assigning values to registers of
primary VM. We say it is the mechanism for hypervisor to communicate with VMs
regulated by FF-A framework. Intuitively, it can be seen as function calls to
VMs, in which $\mathtt{r_{0}}$ stores the function name and the rest store
arguments. We call these registers parameter registers. In the $\INT$ case, the
hypervisor invokes primary VM to handle the ''timer interrupt'' towards the
preempted VM. The scheduler will decide who is the next to run and execute
\instr{run}.

% In Hafnium, the expectation to the scheduler is checking if the $\TIMER$ of
% that VM is zero. If not, the scheduler must execute \instr{run} to allow the VM
% to continue.

The \instr{run} $r$ instruction can only be executed by the primary VM, allowing
primary VM to switch to the VM whose $\VMID$ is stored in $r$ with the help of
the hypervisor. The hypervisor will check if the executer is the primary VM,
and whether the given $\VMID$ is valid. Next, hypervisor examines the state of
$\MB$ of the next running VM. If a message in $\MB$ is ready to read, the
hypervisor additionally sets parameter registers of that VM, notifying the VM
along with the sender and the length of the message.\todo{the pvm is responsible
for setting the timer, to do so the timer must be a register. Or it is ok to let
hypervisor do it?}

The second scheduling related instruction is \instr{yld}. It is executed by a VM
when it wants to yield the CPU and pass control to the scheduler. The semantic
of this instruction is trivial, it just informs primary the previous running VM
yielded. The expectation to scheduler is it must not run that VM again
immediately.

% However, there is an expectation for $\YIELD$ to the primary VM,
% which is that the yielding VM must be run through \instr{run} after a given
% timeout.

The instruction \instr{msgw} is used by a VM to wait for a message. While in
fact, \instr{msgw} is essentially a scheduling instruction. When it is executed
by a VM, the hypervisor will inspect the $\MB$. If there is a ready message, the
control is given back to the VM, notifying it in the same manner as \instr{run}.
Otherwise, hypervisor informs the scheduler that the VM is waiting and switch to
the scheduler. The scheduler is expected not to run that VM again unless a message
to the VM is sent.



%\section{Proof Rules}





\end{document}
