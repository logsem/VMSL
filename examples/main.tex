\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{listings}
\usepackage{bytefield}
\usepackage{xcolor}

\definecolor{lightgray}{gray}{0.8}

\begin{document}

\section{Memory donation}

\subsection{Scheduler $\rightarrow$ secondary VM}

\subsubsection{Bare-bones version}

Assumptions:
\begin{enumerate}
 \item VM0 owns pages p1, p2 and have an exclusive access to them
 \item TX\_0\_Hyp, and TX\_0\_1 are TX buffers that are shared between VM0/Hypervisor, and VM0/VM1 respectfully 
 \item The following memory slice of the TX\_0\_Hyp buffer is valid: \\
     \\
     \begin{bytefield}[rightcurly=., rightcurlyspace=0pt, bitwidth=1.2em]{16}
         \bitheader[endianness=little]{0,2,3,4,8,16} \\
         \begin{rightwordgroup}{n}
             \bitbox{2}{0x0}
	         \bitbox{1}[bgcolor=lightgray]{}
	         \bitbox{1}[bgcolor=lightgray]{}
	         \bitbox{4}{0x0}
	         \bitbox{8}{0x0}
         \end{rightwordgroup} \\
         \begin{rightwordgroup}{n + 0x10}
             \bitbox{8}[bgcolor=lightgray]{}
	         \bitbox{4}[bgcolor=lightgray]{}
	         \bitbox{4}{0x1}
         \end{rightwordgroup} \\
         \begin{rightwordgroup}{n + 0x20}
             \bitbox{2}{0x1}
             \bitbox{1}[bgcolor=lightgray]{}
             \bitbox{1}[bgcolor=lightgray]{}
             \bitbox{4}{m - n}
             \bitbox{8}[bgcolor=lightgray]{}
         \end{rightwordgroup} \\
         \skippedwords \\
         \begin{rightwordgroup}{m}
             \bitbox{4}{0x2}
             \bitbox{4}{0x2}
             \bitbox{8}[bgcolor=lightgray]{}
         \end{rightwordgroup} \\
         \begin{rightwordgroup}{m + 0x10}
             \bitbox{8}{addr(p1)}
             \bitbox{4}{0x1}
             \bitbox{4}[bgcolor=lightgray]{}
         \end{rightwordgroup} \\
         \begin{rightwordgroup}{m + 0x20}
             \bitbox{8}{addr(p2)}
             \bitbox{4}{0x1}
             \bitbox{4}[bgcolor=lightgray]{}
         \end{rightwordgroup}
     \end{bytefield}
\end{enumerate}

\begin{lstlisting}[caption={VM 0}]
# memory donation ffa call
mov R0, 0x84000071 # function id (FFA_MEM_DONATE)
mov R1, 0x30       # Total length of the memory transaction 
                   # descriptor in bytes
mov R2, 0x30       # Length in bytes of the memory transaction 
                   # descriptor passed in this ABI invocation
                   # (it's possible to split it in a number of fragments)
mov R3, 0x0        # (base address of a buffer) used if 
                   # transaction descriptor is sent in 
                   # dynamically allocated buffers, mbz otherwise
mov R4, 0x0        # (number of 4K pages in a buffer) used if 
                   # transaction descriptor is sent in 
                   # dynamically allocated buffers, mbz otherwise
mov R5, 0x0        # mbz
mov R6, 0x0        # mbz
mov R7, 0x0        # mbz
hvc

# R3 is populated with the page handler at this point

# we need to inform VM 1 of the handler by sending an indirect message
mov R0, 0x8400006E # function id (FFA_MSG_SEND)

# Bit[31:16]: Sender endpoint ID.
# Bit[15:0]: Receiver endpoint ID.
# In this case, it's redundant, however, it's kept as an example
mov R1, 0x0
mov R1, R1, LSL 16 # caller id
add R1, 0x1        # callee id
mov R4, addr(TX_0_1)
str R2, [R4, 8]    # store the handler in TX_0_1 buffer of VM0
str R3, [R4, 12]
hvc
\end{lstlisting}

\begin{lstlisting}[caption={VM 1}]
# Copy RX to TX

mov R0, 0x84000074 # function id (FFA_MEM_RETRIEVE_REQ)
mov R1, 0x30       # Total length of the memory transaction 
                   # descriptor in bytes
mov R2, 0x30       # Length in bytes of the memory transaction 
                   # descriptor passed in this ABI invocation
                   # (it's possible to split it in a number of fragments)
mov R3, 0x0        # (base address of a buffer) used if 
                   # transaction descriptor is sent in 
                   # dynamically allocated buffers, mbz otherwise
mov R4, 0x0        # (number of 4K pages in a buffer) used if 
                   # transaction descriptor is sent in 
                   # dynamically allocated buffers, mbz otherwise
mov R5, 0x0        # mbz
mov R6, 0x0        # mbz
mov R7, 0x0        # mbz
hvc
\end{lstlisting}

\subsubsection{OpSem version}

\begin{lstlisting}[caption={VM 0}]
# save 42
mov R0, addr(p, 0)              # p address
mov R1, 42                      # payload
str R0, R1                      # write payload to p

# mem_donate
# arguments
mov R0, encode_fid(MEM_DONATE)  # function id (FFA_MEM_DONATE)
mov R1, 6                       # Total length of the  
                                # memory transaction descriptor
# VMID of the Sender 
mov R2, addr(tx, 0)             # TX buffer address                               
mov R3, 0
str R2, R3

# flag
mov R2, addr(tx, 1)             # TX buffer address (offset 1)                               
mov R3, 0                       # not zeroed
str R2, R3

# handle (mbz)
mov R2, addr(tx, 2)             # TX buffer address (offset 2)
mov R3, 0
str R2, R3

# tag (extra information)
mov R2, addr(tx, 3)             # TX buffer address (offset 3)
mov R3, 0
str R2, R3

# access descriptor count (must be 1 for donation)
mov R2, addr(tx, 4)             # TX buffer address (offset 4)
mov R3, 1
str R2, R3

# VMID of the Receiver
mov R2, addr(tx, 5)             # TX buffer address (offset 5)
mov R3, 1
str R2, R3

# base address of the donated page
mov R2, addr(tx, 6)             # TX buffer address (offset 6)
mov R3, addr(p, 0)              # p address
str R2, R3

hvc            # [0].pt[p] = (O, NA)
               # [1].pt[p] = (!O, NA)
               # sss[handler] = (0, flag, tag, inl (1, p), MEM_DONATE)

# R2 is populated with the transaction discriptor at this point
# save it to the discriptor
mov R3, addr(tx, 2)             # TX buffer address (offset 2)
str R3, R2

# msg_send
mov R0, encode_fid(MSG_SEND)    # function id (FFA_MSG_SEND)
mov R1, 1                       # VMID of the Receiver
mov R2, 6                       # message length

hvc
\end{lstlisting}

\begin{lstlisting}[caption={VM 1}]
# retrieve msg length
mov R0, encode_fid(MSG_WAIT)    # function id (FFA_MSG_WAIT)
hvc

# R1 is populated with length of the message at this point

# Copy RX to TX
mov R0, 0             # value to compare with
mov R2, loop          # jump point
mov R3, 1             # step
mov R4, addr(rx, 0)   # RX buffer base address
mov R5, addr(tx, 0)   # TX buffer base address
loop:
sub R1, R1, R3
cmp R1, R0
ldr R6, R4
str R5, R6
add R4, R4, R3
bne R2

mov R0, encode_fid(MEM_RETRIEVE_REQ) # function id (FFA_MEM_RETRIEVE_REQ)
mov R1, 4                            # Total length of the  
                                     # memory transaction descriptor in bytes
# access descriptor count (must be 0 for mem_retrieve)
mov R2, addr(tx, 4)           # TX buffer address (offset 4)
mov R3, 0
str R2, R3                                    
hvc               # [0].pt[p] = (!O, NA)
                  # [1].pt[p] = (O, EA)
                  # find(sss, handler) = False
\end{lstlisting}

\subsection{Secondary VM $\rightarrow$ secondary VM}

\subsubsection{Bare-bones version}
Assumptions:
\begin{enumerate}
 \item VM1 owns pages p1, p2 and have an exclusive access to them
 \item The following memory slice of the TX\_1\_Hyp buffer is valid: \\
     \\
     \begin{bytefield}[rightcurly=., rightcurlyspace=0pt, bitwidth=1.2em]{16}
         \bitheader[endianness=little]{0,2,3,4,8,16} \\
         \begin{rightwordgroup}{n}
             \bitbox{2}{0x1}
	         \bitbox{1}[bgcolor=lightgray]{}
	         \bitbox{1}[bgcolor=lightgray]{}
	         \bitbox{4}{0x0}
	         \bitbox{8}{0x0}
         \end{rightwordgroup} \\
         \begin{rightwordgroup}{n + 0x10}
             \bitbox{8}[bgcolor=lightgray]{}
	         \bitbox{4}[bgcolor=lightgray]{}
	         \bitbox{4}{0x1}
         \end{rightwordgroup} \\
         \begin{rightwordgroup}{n + 0x20}
             \bitbox{2}{0x2}
             \bitbox{1}[bgcolor=lightgray]{}
             \bitbox{1}[bgcolor=lightgray]{}
             \bitbox{4}{m - n}
             \bitbox{8}[bgcolor=lightgray]{}
         \end{rightwordgroup} \\
         \skippedwords \\
         \begin{rightwordgroup}{m}
             \bitbox{4}{0x2}
             \bitbox{4}{0x2}
             \bitbox{8}[bgcolor=lightgray]{}
         \end{rightwordgroup} \\
         \begin{rightwordgroup}{m + 0x10}
             \bitbox{8}{addr(p1)}
             \bitbox{4}{0x1}
             \bitbox{4}[bgcolor=lightgray]{}
         \end{rightwordgroup} \\
         \begin{rightwordgroup}{m + 0x20}
             \bitbox{8}{addr(p2)}
             \bitbox{4}{0x1}
             \bitbox{4}[bgcolor=lightgray]{}
         \end{rightwordgroup}
     \end{bytefield}
\end{enumerate}

\begin{lstlisting}[caption={VM 1}]
# memory donation ffa call
mov R0, 0x84000071 # function id (FFA_MEM_DONATE)
mov R1, 0x30       # Total length of the memory transaction 
                   # descriptor in bytes
mov R2, 0x30       # Length in bytes of the memory transaction 
                   # descriptor passed in this ABI invocation
                   # (it's possible to split it in a number of fragments)
mov R3, 0x0        # (base address of a buffer) used if 
                   # transaction descriptor is sent in 
                   # dynamically allocated buffers, mbz otherwise
mov R4, 0x0        # (number of 4K pages in a buffer) used if 
                   # transaction descriptor is sent in 
                   # dynamically allocated buffers, mbz otherwise
mov R5, 0x0        # mbz
mov R6, 0x0        # mbz
mov R7, 0x0        # mbz
hvc

# R3 is populated with the page handler at this point

# we need to inform VM 1 of the handler by sending an indirect message
mov R0, 0x8400006E # function id (FFA_MSG_SEND)

# Bit[31:16]: Sender endpoint ID.
# Bit[15:0]: Receiver endpoint ID.
mov R1, 0x1
mov R1, R1, LSL 16 # caller id
add R1, 0x2        # callee id
mov R4, addr(TX_0_1)
str R2, [R4, 8]    # store the handler in TX_0_1 buffer of VM0
str R3, [R4, 12]
hvc
\end{lstlisting}

\begin{lstlisting}[caption={VM 0}]
mov R0, 0x8400006D # function id (FFA_RUN)
# Bit[31:16]: Callee ID.
# Bit[15:0]: Callee vCPU ID.
mov R1, 0x1
mov R1, R1, LSL 16 # caller id
add R1, 0x1        # callee id
\end{lstlisting}

\begin{lstlisting}[caption={VM 2}]
# Copy RX to TX

mov R0, 0x84000074 # function id (FFA_MEM_RETRIEVE_REQ)
mov R1, 0x30       # Total length of the memory transaction 
                   # descriptor in bytes
mov R2, 0x30       # Length in bytes of the memory transaction 
                   # descriptor passed in this ABI invocation
                   # (it's possible to split it in a number of fragments)
mov R3, 0x0        # (base address of a buffer) used if 
                   # transaction descriptor is sent in 
                   # dynamically allocated buffers, mbz otherwise
mov R4, 0x0        # (number of 4K pages in a buffer) used if 
                   # transaction descriptor is sent in 
                   # dynamically allocated buffers, mbz otherwise
mov R5, 0x0        # mbz
mov R6, 0x0        # mbz
mov R7, 0x0        # mbz
hvc
\end{lstlisting}

\subsubsection{OpSem version}

\begin{lstlisting}[caption={VM 1}]
# save 42
mov R0, addr(p, 0)              # p address
mov R1, 42                      # payload
str R0, R1                      # write payload to p

# mem_donate
# arguments
mov R0, encode_fid(MEM_DONATE)  # function id (FFA_MEM_DONATE)
mov R1, 6                       # Total length of the  
                                # memory transaction descriptor
# VMID of the Sender 
mov R2, addr(tx, 1)             # TX buffer address                               
mov R3, 0
str R2, R3

# flag
mov R2, addr(tx, 1)             # TX buffer address (offset 1)                               
mov R3, 0                       # not zeroed
str R2, R3

# handle (mbz)
mov R2, addr(tx, 2)             # TX buffer address (offset 2)
mov R3, 0
str R2, R3

# tag (extra information)
mov R2, addr(tx, 3)             # TX buffer address (offset 3)
mov R3, 0
str R2, R3

# access descriptor count (must be 1 for donation)
mov R2, addr(tx, 4)             # TX buffer address (offset 4)
mov R3, 1
str R2, R3

# VMID of the Receiver
mov R2, addr(tx, 5)             # TX buffer address (offset 5)
mov R3, 2
str R2, R3

# base address of the donated page
mov R2, addr(tx, 6)             # TX buffer address (offset 6)
mov R3, addr(p, 0)              # p address
str R2, R3

hvc               # [1].pt[p] = (O, NA)
                  # [2].pt[p] = (!O, NA)
                  # sss[handler] = (1, flag, tag, inl (2, p), MEM_DONATE)

# R2 is populated with the transaction discriptor at this point
# save it to the discriptor
mov R3, addr(tx, 2)             # TX buffer address (offset 2)
str R3, R2

# msg_send
mov R0, encode_fid(MSG_SEND)    # function id (FFA_MSG_SEND)
mov R1, 2                       # VMID of the Receiver
mov R2, 6                       # message length

hvc
\end{lstlisting}

\begin{lstlisting}[caption={VM 0}]
# simple message transmitter
mov R1, R1, LSL 16          # R1 = v << (WORD_BITS/2) + n
mov R1, R1, LSR 16
mov R0, encode_fid(FFA_RUN) # function id (FFA_RUN)
mov R1, 2                   # callee VMID
hvc
\end{lstlisting}

\begin{lstlisting}[caption={VM 2}]
# retrieve msg length
mov R0, encode_fid(MSG_WAIT)   # function id (FFA_MSG_WAIT)
hvc

# R1 is populated with length of the message at this point

# Copy RX to TX
mov R0, 0             # value to compare with
mov R2, loop          # jump point
mov R3, 1             # step
mov R4, addr(rx, 0)   # RX buffer base address
mov R5, addr(tx, 0)   # TX buffer base address
loop:
sub R1, R1, R3
cmp R1, R0
ldr R6, R4
str R5, R6
add R4, R4, R3
bne R2

mov R0, encode_fid(MEM_RETRIEVE_REQ) # function id (FFA_MEM_RETRIEVE_REQ)
mov R1, 4                            # Total length of the  
                                     # memory transaction descriptor in bytes
# access descriptor count (must be 0 for mem_retrieve)
mov R2, addr(tx, 4)             # TX buffer address (offset 4)
mov R3, 0
str R2, R3                                    
hvc               # [1].pt[p] = (!O, NA)
                  # [2].pt[p] = (O, EA)
                  # find(sss, handler) = False
\end{lstlisting}

\section{Memory lending}

\subsection{Scheduler $\rightarrow$ secondary VMs}

\begin{lstlisting}[caption={VM 0}]
# save 42
mov R0, addr(p, 0)              # p address
mov R1, 42                      # payload
str R0, R1                      # write payload to p

# mem_lend
# arguments
mov R0, encode_fid(MEM_LEND)    # function id (FFA_MEM_LEND)
mov R1, 8                       # Total length of the  
                                # memory transaction descriptor
# VMID of the Sender 
mov R2, addr(tx, 0)             # TX buffer address                               
mov R3, 0
str R2, R3

# flag
mov R2, addr(tx, 1)             # TX buffer address (offset 1)                               
mov R3, 0                       # not zeroed
str R2, R3

# handle (mbz)
mov R2, addr(tx, 2)             # TX buffer address (offset 2)
mov R3, 0
str R2, R3

# tag (extra information)
mov R2, addr(tx, 3)             # TX buffer address (offset 3)
mov R3, 0
str R2, R3

# access descriptor count
mov R2, addr(tx, 4)             # TX buffer address (offset 4)
mov R3, 2
str R2, R3

# VMID of the first Receiver
mov R2, addr(tx, 5)             # TX buffer address (offset 5)
mov R3, 1
str R2, R3

# base address of the donated page
mov R2, addr(tx, 6)             # TX buffer address (offset 6)
mov R3, addr(p, 0)              # p address
str R2, R3

# VMID of the second Receiver
mov R2, addr(tx, 7)             # TX buffer address (offset 5)
mov R3, 2
str R2, R3

# base address of the donated page
mov R2, addr(tx, 8)             # TX buffer address (offset 6)
mov R3, addr(p, 0)              # p address
str R2, R3

hvc            # [0].pt[p] = (O, NA)
               # [1].pt[p] = (!O, NA)
               # [2].pt[p] = (!O, NA)
               # sss[handler] = 
               # (0, flag, tag, inr (0, [(1, p), (2, p)]), MEM_LEND)

# R2 is populated with the transaction handler at this point
# save it to the discriptor
mov R3, addr(tx, 2)          # TX buffer address (offset 2)
str R3, R2

mov R4, R2                   # save the handler for later

# msg_send
mov R0, encode_fid(MSG_SEND)    # function id (FFA_MSG_SEND)
mov R1, 1                       # VMID of the Receiver
mov R2, 8                       # message length
hvc 

mov R1, 2                       # VMID of the Receiver
mov R2, 8                       # message length
hvc

# reclaim
mov R0, encode_id(MEM_RECLAIM)
mov R2, R4                       # handler
mov R3, 0                        # flag
hvc            # [0].pt[p] = (O, EA)
               # [1].pt[p] = (!O, NA)
               # [2].pt[p] = (!O, NA)
               # find(sss, handler) = False       
\end{lstlisting}

\begin{lstlisting}[caption={VM 1}]
# retrieve msg length
mov R0, encode_fid(MSG_WAIT)   # function id (FFA_MSG_WAIT)
hvc

# R1 is populated with length of the message at this point

# Copy RX to TX
mov R0, 0             # value to compare with
mov R2, loop          # jump point
mov R3, 1             # step
mov R4, addr(rx, 0)   # RX buffer base address
mov R5, addr(tx, 0)   # TX buffer base address
loop:
sub R1, R1, R3
cmp R1, R0
ldr R6, R4
str R5, R6
add R4, R4, R3
bne R2

mov R0, encode_fid(MEM_RETRIEVE_REQ) # function id (FFA_MEM_RETRIEVE_REQ)
mov R1, 4                            # Total length of the  
                                     # memory transaction descriptor in bytes
# access descriptor count (must be 0 for mem_retrieve)
mov R2, addr(tx, 4)                  # TX buffer address (offset 4)
mov R3, 0
str R2, R3                                    
hvc            # [0].pt[p] = (O, NA)
               # [1].pt[p] = (!O, SA)
               # [2].pt[p] = (!O, NA)
               # sss[handler] = 
               # (0, flag, tag, inr (1, [(1, p), (2, p)]), MEM_LEND)

# save 24
mov R0, addr(p, 0)              # p address
mov R1, 24                      # payload
str R0, R1                      # write payload to p

# handler for relinquishing
mov R0, encode_fid(MEM_RELINQUISH)
mov R1, addr(tx, 2)
ldr R2, R1                      # save the old handler
mov R1, addr(tx, 1)
ldr R3, R1                      # save the old flag
mov R1, addr(tx, 0)             # TX buffer address
str R1, R2                      # handler for a new descriptor
mov R1, addr(tx, 1)
str R1, R3                      # flag for a new descriptor
hvc            # [0].pt[p] = (O, NA)
               # [1].pt[p] = (!O, NA)
               # [2].pt[p] = (!O, NA)
               # sss[handler] = 
               # (0, flag, tag, inr (0, [(1, p), (2, p)]), MEM_LEND)

# yield
mov R0, encode_fid(YIELD)     # function id (FFA_YIELD)
hvc
\end{lstlisting}

\begin{lstlisting}[caption={VM 2}]
# retrieve msg length
mov R0, encode_fid(MSG_WAIT)   # function id (FFA_MSG_WAIT)
hvc

# R1 is populated with length of the message at this point

# Copy RX to TX
mov R0, 0             # value to compare with
mov R2, loop          # jump point
mov R3, 1             # step
mov R4, addr(rx, 0)   # RX buffer base address
mov R5, addr(tx, 0)   # TX buffer base address
loop:
sub R1, R1, R3
cmp R1, R0
ldr R6, R4
str R5, R6
add R4, R4, R3
bne R2

mov R0, encode_fid(MEM_RETRIEVE_REQ) # function id (FFA_MEM_RETRIEVE_REQ)
mov R1, 4                            # Total length of the  
                                     # memory transaction descriptor in bytes
# access descriptor count (must be 0 for mem_retrieve)
mov R2, addr(tx, 4)                  # TX buffer address (offset 4)
mov R3, 0
str R2, R3                                    
hvc            # [0].pt[p] = (O, NA)
               # [1].pt[p] = (!O, NA)
               # [2].pt[p] = (!O, SA)
               # sss[handler] = 
               # (0, flag, tag, inr (1, [(1, p), (2, p)]), MEM_LEND)

# handler for relinquishing
mov R0, encode_fid(MEM_RELINQUISH)
mov R1, addr(tx, 2)
ldr R2, R1                      # save the old handler
mov R1, addr(tx, 1)
ldr R3, R1                      # save the old flag
mov R1, addr(tx, 0)             # TX buffer address
str R1, R2                      # handler for a new descriptor
mov R1, addr(tx, 1)
str R1, R3                      # flag for a new descriptor
hvc            # [0].pt[p] = (O, NA)
               # [1].pt[p] = (!O, NA)
               # [2].pt[p] = (!O, NA)
               # sss[handler] = 
               # (0, flag, tag, inr (0, [(1, p), (2, p)]), MEM_LEND)

# yield
mov R0, encode_fid(YIELD)     # function id (FFA_YIELD)
hvc
\end{lstlisting}

\section*{Appendix}

\subsection*{A. Memory transaction descriptor}

\begin{bytefield}[bitwidth=1.4em]{32}
	\bitheader[endianness=little]{0,2,3,4,8,16,24,28,32}\\
	\bitbox{2}{\small ID$_s$}
	\bitbox{1}{\tiny M \\ R \\ A}
	\bitbox{1}[bgcolor=lightgray]{}
	\bitbox{4}{Flag}
	\bitbox{8}{Handle}
	\bitbox{8}{Tag}
	\bitbox{4}[bgcolor=lightgray]{}
	\bitbox{4}{Length}
\end{bytefield}

MRA (memory region attributes) are used to specify:
\begin{enumerate}
    \item Memory type (different device types and normal)
    \item Cacheability
    \item Shareability 
\end{enumerate}

This field may be safely ignored for now.

The first flag bit is used to request the Relayer to zero a memory region in FFA\_MEM\_DONATE or FFA\_MEM\_LEND. In an invocation of FFA\_MEM\_SHARE it must be zero'ed (else the Relayer must return INVALID\_PARAMETERS). If the Owner has Read-Only access to the memory region it also must be zero'ed (else the Relayer must return DENIED).

The second flag bit is used to show the Relayer that it can use time slicing. If the Relayer does not support memory slicing then it must be zero'ed, else the Relayer must return INVALID\_PARAMETERS. It can safely be ignored for now.

There's some complex behavior for these bits in FFA\_MEM\_RETRIEVE\_REQ ABI.

In FFA\_MEM\_RETRIEVE\_RESP ABI the first flag shows if the memory region was retrieved with(out) zeroing its content. The 4th and 5th bits are used to show the transaction type (important!). 

Tag specifies a value, which determines an implementation defined behavior so it can be ignored for now.

Handle must be zero'ed in an invocation of FFA\_MEM\_DONATE, FFA\_MEM\_LEND, FFA\_MEM\_SHARE.

Unused parts MBZ.

Length specifies a count of endpoint memory access descriptors.

The structure is followed by an array of endpoint memory access descriptors.

\subsection*{B. Endpoint memory access descriptor}

\begin{bytefield}[bitwidth=2.5em]{16}
	\bitheader[endianness=little]{0,2,3,4,8,16}\\	
	\bitbox{2}{\small ID$_r$}
	\bitbox{1}{\tiny M \\ A \\ P}
	\bitbox{1}{\small Flags}
	\bitbox{4}{\tiny CM region descriptor \\ offset}
	\bitbox{8}[bgcolor=lightgray]{}
\end{bytefield}

MAP (memory access permission) are used to specify instruction and access permissions for a memory region.

Offset must be calculated from the base address of
the data structure this descriptor is included in.

An offset value of 0 indicates that the endpoint
access permissions apply to a memory region
description identified by the Handle parameter
specified in the data structure that includes this
one.

\subsection*{C. Composite memory region descriptor}

\begin{bytefield}[bitwidth=2.5em]{16}
	\bitheader[endianness=little]{0,4,8,16}\\	
	\bitbox{4}{Total page count}
	\bitbox{4}{Address range count}
	\bitbox{8}[bgcolor=lightgray]{}
\end{bytefield}

Total page count specifies the size of the memory region described as the count
of 4K pages. It must be equal to the sum of page counts specified
in each constituent memory region descriptor.

Address range count indicates the count of address ranges specified using
constituent memory region descriptors.

The structure is followed by an array of constituent memory region descriptors.

\subsection*{D. Constituent memory region descriptor}

\begin{bytefield}[bitwidth=2.5em]{16}
	\bitheader[endianness=little]{0,8,12,16}\\	
	\bitbox{8}{Address}
	\bitbox{4}{Page count}
	\bitbox{4}[bgcolor=lightgray]{}
\end{bytefield}

The structure keeps information about base VA, PA or IPA of constituent memory region aligned to
the page size 4K granularity, and number of 4K pages.

\end{document}
