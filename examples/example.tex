\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{pgf-umlsd}
\usepackage{afterpage}
\usepackage{hyperref}

\newenvironment*{returnanother}[6][1]{
  \stepcounter{seqlevel}
  \stepcounter{callevel} % push
  \path
  (#2)+(0,-\theseqlevel*\unitfactor-0.7*\unitfactor) node (cf\thecallevel) {}
  (#4.\threadbias)+(0,-\theseqlevel*\unitfactor-0.7*\unitfactor) node (ct\thecallevel) {};
  \draw[->,>=triangle 60] ({cf\thecallevel}) -- (ct\thecallevel)
  node[midway, above] {#3};
  \def\l\thecallevel{#1}
  \def\f\thecallevel{#6}
  \def\t\thecallevel{#4}
  \def\returnvalue{#5}
  \tikzstyle{threadstyle}+=[instcolor#2]
    \addtocounter{seqlevel}{1}
  \path
  (\f\thecallevel)+(0,-\theseqlevel*\unitfactor-0.7*\unitfactor) node (rf\thecallevel) {}
  (\t\thecallevel.\threadbias)+(0,-\theseqlevel*\unitfactor-0.7*\unitfactor) node (rt\thecallevel) {};
  \draw[dashed,->,>=angle 60] ({rt\thecallevel}) -- (rf\thecallevel)
  node[midway, above]{\returnvalue};
  \drawthread{ct\thecallevel}{rt\thecallevel}
}
{
\addtocounter{seqlevel}{\thecallevel}
%   \path
%   (\f\thecallevel.\threadbias)+(0,-\theseqlevel*\unitfactor+\unitfactor+\l\thecallevel*\unitfactor-0.7*\unitfactor) node (rrf\thecallevel) {}
%   (\f\thecallevel.\threadbias)+(0,-\theseqlevel*\unitfactor-0.7*\unitfactor) node (rff\thecallevel) {};
%  \drawthread{rrf\thecallevel}{rff\thecallevel}
  \addtocounter{callevel}{-1} % pop
  \addtocounter{seqlevel}{-1}
}


\begin{document}

\subsection{Scheduler $\rightarrow$ secondary VM}

Initially, VM 0 has both ownership and exclusive access to page $p$. After a complete lending transaction it loses an access to this page, and passes exclusive access to VM 1. After that, VM 1 relinquish access to the page, and the initial owner reclaims access.

More precisely, VM 0 initiates a memory lending transaction by populating a memory transaction descriptor (within its TX buffer) with receivers' IDs, PIDs, and some auxiliary information. R0 is populated with a function id of FFA\_MEM\_LEND, R1 is populated with a length of a memory descriptor. FFA\_MEM\_LEND returns a handle for this transaction. At this point, VM 0 owns the page but loses access to it. After the transaction initiation, VM 0 populates the memory transaction descriptor with the handle, and sends it via FFA\_MSG\_SEND (perhaps, without endpoint array), and transfers control to VM 1. VM 1 copies the memory transaction descriptor from its RX to TX buffer, and finishes the transaction by calling FFA\_MEM\_RETRIEVE. Now, VM 1 has exclusive access to the page. After that, VM 1 manipulate its newly acquired memory, relinquishes its access to it, and yields control back to VM 0. VM 0 reclaims access to the page.

\begin{figure}[hbt!]
\centering
\begin{sequencediagram}
    \newinst{Hyp}{Hypervisor}
    \newinst[3]{VM0}{VM 0}
    \newinst[3]{VM1}{VM 1}

    \begin{call}{VM0}{MEM\_LEND (1)}{Hyp}{SUCCESS}
    \end{call}

    \begin{call}{VM0}{MSG\_SEND (1)}{Hyp}{}
    \end{call}

    \begin{returnanother}{VM0}{RUN (1)}{Hyp}{}{VM1}
    \end{returnanother}

    \begin{call}{VM1}{MSG\_WAIT}{Hyp}{MSG\_SEND}
    \end{call}

    \begin{call}{VM1}{MEM\_RETRIEVE\_REQ}{Hyp}{MEM\_RETRIEVE\_RESP}
    \end{call}

    \begin{call}{VM1}{MEM\_RELINQUISH}{Hyp}{SUCCESS}
    \end{call}

    \begin{returnanother}{VM1}{YIELD}{Hyp}{}{VM0}
    \end{returnanother}

    \begin{call}{VM0}{MEM\_RECLAIM}{Hyp}{SUCCESS}
    \end{call}

\end{sequencediagram}

\end{figure}



\clearpage

\begin{lstlisting}[caption={VM 0}]
# save 42
mov R0, addr(p, 0)              # p address
mov R1, 42                      # payload
str R0, R1                      # write payload to p

# mem_lend
# arguments
mov R0, encode_fid(MEM_LEND)    # function id (FFA_MEM_LEND)
mov R1, 8                       # Total length of the
                                # memory transaction descriptor
# VMID of the Sender
mov R2, addr(tx, 0)             # TX buffer address
mov R3, 0
str R2, R3

# flag
mov R2, addr(tx, 1)             # TX buffer address (offset 1)
mov R3, 0                       # not zeroed
str R2, R3

# handle (mbz)
mov R2, addr(tx, 2)             # TX buffer address (offset 2)
mov R3, 0
str R2, R3

# tag (extra information)
mov R2, addr(tx, 3)             # TX buffer address (offset 3)
mov R3, 0
str R2, R3

# access descriptor count
mov R2, addr(tx, 4)             # TX buffer address (offset 4)
mov R3, 1
str R2, R3

# VMID of the first Receiver
mov R2, addr(tx, 5)             # TX buffer address (offset 5)
mov R3, 1
str R2, R3

# base address of the donated page
mov R2, addr(tx, 6)             # TX buffer address (offset 6)
mov R3, addr(p, 0)              # p address
str R2, R3

hvc            # [0].pt[p] = (O, NA)
               # [1].pt[p] = (!O, NA)
               # sss[handler] =
               # (0, flag, tag, inl (1, p), MEM_LEND)

# R2 is populated with the transaction handler at this point
# save it to the discriptor
mov R3, addr(tx, 2)          # TX buffer address (offset 2)
str R3, R2

mov R4, R2                   # save the handler for later

# msg_send to 1
mov R0, encode_fid(MSG_SEND)    # function id (FFA_MSG_SEND)
mov R1, 1                       # VMID of the Receiver
mov R2, 8                       # message length
hvc

# run 1
mov R0, encode_fid(FFA_RUN)
mov R1, 1
hvc

# reclaim
mov R0, encode_id(MEM_RECLAIM)
mov R2, R4                       # handler
mov R3, 0                        # flag
hvc            # [0].pt[p] = (O, EA)
               # [1].pt[p] = (!O, NA)
               # find(sss, handler) = False
\end{lstlisting}

\begin{lstlisting}[caption={VM 1}]
# retrieve msg length
mov R0, encode_fid(MSG_WAIT)   # function id (FFA_MSG_WAIT)
hvc

# R1 is populated with length of the message at this point

# Copy RX to TX
mov R0, 0             # value to compare with
mov R2, loop          # jump point
mov R3, 1             # step
mov R4, addr(rx, 0)   # RX buffer base address
mov R5, addr(tx, 0)   # TX buffer base address
loop:
sub R1, R1, R3
cmp R1, R0
ldr R6, R4
str R5, R6
add R4, R4, R3
bne R2

mov R0, encode_fid(MEM_RETRIEVE_REQ) # function id (FFA_MEM_RETRIEVE_REQ)
mov R1, 4                            # Total length of the
                                     # memory transaction descriptor in bytes
# access descriptor count (must be 0 for mem_retrieve)
mov R2, addr(tx, 4)                  # TX buffer address (offset 4)
mov R3, 0
str R2, R3
hvc            # [0].pt[p] = (O, NA)
               # [1].pt[p] = (!O, EA)
               # sss[handler] =
               # (0, flag, tag, inl (1, p), MEM_LEND)

# save 24
mov R0, addr(p, 0)              # p address
mov R1, 24                      # payload
str R0, R1                      # write payload to p

# handler for relinquishing
mov R0, encode_fid(MEM_RELINQUISH)
mov R1, addr(tx, 2)
ldr R2, R1                      # save the old handler
mov R1, addr(tx, 1)
ldr R3, R1                      # save the old flag
mov R1, addr(tx, 0)             # TX buffer address
str R1, R2                      # handler for a new descriptor
mov R1, addr(tx, 1)
str R1, R3                      # flag for a new descriptor
hvc            # [0].pt[p] = (O, NA)
               # [1].pt[p] = (!O, NA)
               # sss[handler] =
               # (0, flag, tag, inl (1, p), MEM_LEND)

# yield
mov R0, encode_fid(YIELD)     # function id (FFA_YIELD)
hvc
\end{lstlisting}

\end{document}
