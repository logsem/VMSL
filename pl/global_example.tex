\documentclass{book}

\usepackage[margin=2cm,landscape,a3paper]{geometry}%
\usepackage{iris}
\usepackage{bussproofs}
\usepackage{float}
\usepackage{multicol,multirow}
\usepackage{amsmath}
\usepackage{mathpartir}
\usepackage{mathtools}
\usepackage{hyperref}
\usepackage{todonotes}
\usepackage{graphicx}
\usepackage{kpfonts}
\usepackage{array}
\usepackage{listings}
\usepackage{caption}
\usepackage{subcaption}

\newcommand*{\VMTOK}[1]{%
    \lozenge^{#1}
}
\newcommand*{\REG}[1]{
    \mathtt{#1}
}
\newcommand*{\vdashv}{\dashv \vdash}
\newcommand*{\defined}{\triangleq}
\newcommand*{\mapsText}[1]{\xrightarrow{#1}}
\newcommand*{\maps}{\rightarrow}
\newcommand*{\derived}{::=}
\newcommand*{\PID}{\text{PID}}
\newcommand*{\AS}{\text{AccessState}}
\newcommand*{\OS}{\text{OwnershipState}}
\newcommand*{\ADDR}{\text{Address}}
\newcommand*{\WORD}{\text{Word}}
\newcommand*{\VMID}{\text{VMID}}
\newcommand*{\REGNAMES}{\text{RegisterName}}
\newcommand*{\DONE}{\text{DoneState}}
\newcommand*{\INSTR}{\text{Instruction}}
\newcommand*{\LOC}{\text{Loc}}
\newcommand*{\VAL}{\text{Val}}
\newcommand*{\GREGS}{\text{GenRegs}}
\newcommand*{\VM}{\text{VM}}
\newcommand*{\PABITS}{\text{ADDR\_BITS}}
\newcommand*{\PPBITS}{\text{PAGE\_BITS}}
\newcommand*{\PPIDBITS}{\text{PID\_BITS}}
\newcommand*{\PAMAX}{\text{ADDR\_MAX}}
\newcommand*{\PPMAX}{\text{PAGE\_MAX}}
\newcommand*{\PPIDMAX}{\text{PID\_MAX}}
\newcommand*{\PWBITS}{\text{WORD\_BITS}}
\newcommand*{\PWMAX}{\text{WORD\_MAX}}
\newcommand*{\PVMMAX}{\text{VM\_MAX}}
\newcommand*{\instrm}[1]{\mathtt{#1}}
\newcommand*{\instr}[1]{\texttt{#1}}
\newcommand*{\EI}[1]{\mathtt{ExecInstr} \; {#1}}
\newcommand*{\RP}[1]{\mathtt{Repeat} \; {#1}}
\newcommand*{\DN}[1]{\mathtt{Done} \; {#1}}
\newcommand*{\NXT}[1]{\mathtt{Next} \; {#1}}
\newcommand{\SOME}{\mathtt{Some}}
\newcommand{\NONE}{\mathtt{None}}
\newcommand{\False}{\text{False}}
\newcommand{\T}{\text{T}}
\newcommand{\R}{\text{R}}

\begin{document}

% 4B per instruction
% 4KB page
% p0 contains instructions for VM0
% p1 contains instructions for VM1
% t0/r0 - VM0 tx/rx buffers
% t1/r1 - VM1 tx/rx buffers
% pc = pc + 4
% Nat64b + Bottom
\begin{figure}[hbt!]
\centering
\begin{subfigure}{.5\textwidth}
\centering
\begin{lstlisting}
# save 42
mov R0, addr(p, 0)              # p address
mov R1, 42                      # payload
str R0, R1                      # write payload to p

# mem_lend
# arguments
mov R0, encode_fid(MEM_LEND)    # function id (FFA_MEM_LEND)
mov R1, 8                       # Total length of the  
                                # memory transaction descriptor
# VMID of the Sender 
mov R2, addr(tx, 0)             # TX buffer address                               
mov R3, 0
str R2, R3

# flag
mov R2, addr(tx, 1)             # TX buffer address (offset 1)                               
mov R3, 0                       # not zeroed
str R2, R3

# handle (mbz)
mov R2, addr(tx, 2)             # TX buffer address (offset 2)
mov R3, 0
str R2, R3

# tag (extra information)
mov R2, addr(tx, 3)             # TX buffer address (offset 3)
mov R3, 0
str R2, R3

# access descriptor count
mov R2, addr(tx, 4)             # TX buffer address (offset 4)
mov R3, 1
str R2, R3

# VMID of the first Receiver
mov R2, addr(tx, 5)             # TX buffer address (offset 5)
mov R3, 1
str R2, R3

# base address of the donated page
mov R2, addr(tx, 6)             # TX buffer address (offset 6)
mov R3, addr(p, 0)              # p address
str R2, R3

hvc            # [0].pt[p] = (O, NA)
               # [1].pt[p] = (!O, NA)
               # sss[handler] = 
               # (0, flag, tag, inl (1, p), MEM_LEND)

# R2 is populated with the transaction handler at this point
# save it to the discriptor
mov R3, addr(tx, 2)          # TX buffer address (offset 2)
str R3, R2

mov R4, R2                   # save the handler for later

\end{lstlisting}
\label{fig:sub1}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
\centering
\begin{lstlisting}

# msg_send to 1
mov R0, encode_fid(MSG_SEND)    # function id (FFA_MSG_SEND)
mov R1, 1                       # VMID of the Receiver
mov R2, 8                       # message length
hvc

# run 1
mov R0, encode_fid(FFA_RUN)
mov R1, 1
hvc

# reclaim
# mov R0, encode_id(MEM_RECLAIM)
# mov R2, R4                       # handler
# mov R3, 0                        # flag
# hvc            # [0].pt[p] = (O, EA)
                 # [1].pt[p] = (!O, NA)
                 # find(sss, handler) = False       
\end{lstlisting}
\label{fig:sub2}
\end{subfigure}
\caption{VM 0}
\label{fig:test}
\end{figure}

\begin{figure}[hbt!]
\begin{lstlisting}
# retrieve msg length
mov R0, encode_fid(MSG_WAIT)   # function id (FFA_MSG_WAIT)
hvc

# R1 is populated with length of the message at this point

# Copy RX to TX
mov R0, 0             # value to compare with
mov R2, loop          # jump point
mov R3, 1             # step
mov R4, addr(rx, 0)   # RX buffer base address
mov R5, addr(tx, 0)   # TX buffer base address
loop:
sub R1, R1, R3
cmp R1, R0
ldr R6, R4
str R5, R6
add R4, R4, R3
bne R2

mov R0, encode_fid(MEM_RETRIEVE_REQ) # function id (FFA_MEM_RETRIEVE_REQ)
mov R1, 4                            # Total length of the  
                                     # memory transaction descriptor in bytes
# access descriptor count (must be 0 for mem_retrieve)
mov R2, addr(tx, 4)                  # TX buffer address (offset 4)
mov R3, 0
str R2, R3                                    
hvc            # [0].pt[p] = (O, NA)
               # [1].pt[p] = (!O, EA)
               # sss[handler] = 
               # (0, flag, tag, inl (1, p), MEM_LEND)

# save 24
mov R0, addr(p, 0)              # p address
mov R1, 24                      # payload
str R0, R1                      # write payload to p

# handler for relinquishing
# mov R0, encode_fid(MEM_RELINQUISH)
# mov R1, addr(tx, 2)
# ldr R2, R1                      # save the old handler
# mov R1, addr(tx, 1)
# ldr R3, R1                      # save the old flag
# mov R1, addr(tx, 0)             # TX buffer address
# str R1, R2                      # handler for a new descriptor
# mov R1, addr(tx, 1)
# str R1, R3                      # flag for a new descriptor
# hvc            # [0].pt[p] = (O, NA)
#                # [1].pt[p] = (!O, NA)
#                # sss[handler] = 
#                # (0, flag, tag, inl (1, p), MEM_LEND)

# yield
mov R0, encode_fid(YIELD)     # function id (FFA_YIELD)
hvc
\end{lstlisting}
\caption{VM 1}
\end{figure}

\clearpage

Assumptions: $VM(0)[\REG{PC}] \mapsto instr * OE_0(p0)$ and $VM(1)[\REG{PC}] \mapsto instr * OE_1(p1)$

\begin{figure}[hbt!]
\begin{prooftree}
\AxiomC{\textbf{decodeInstr(instr) = mov R0, addr(p, 0)}}
\LeftLabel{\scriptsize(mov)}
\UnaryInfC{$\hoareV{\later \VM(0)[\REG{PC}] = addr(p0, 0)
                  * \later \VMTOK{0}}
                    {\textsf{ExecInstr 0}}
                    {v, v = Done Next 0 
                  * \VM(0)[\REG{PC}] = addr(p0, 4) 
                  * \VMTOK{0}
                  * VM(0)[\REG{R0}] = addr(p, 0)}$}

\AxiomC{\textbf{decodeInstr(instr) = mov R1, 42}}
\RightLabel{\scriptsize(mov)}
\UnaryInfC{$\hoareV{\later \VM(0)[\REG{PC}] = addr(p0, 4) 
                  * \later \VMTOK{0}}
                    {\textsf{ExecInstr 0}}
                    {q, q = \textsf{Done Next 0}
                  * \VM(0)[\REG{PC}] = addr(p0, 8)
                  * \VMTOK{0}
                  * VM(0)[\REG{R1}] = 42}$}
\RightLabel{\scriptsize(? + Csq + Frame)}
\UnaryInfC{$\forall v. 
            \hoareV{v = \textsf{Done Next 0} 
                  * \later \VM(0)[\REG{PC}] = addr(p0, 4) 
                  * \later \VMTOK{0}
                  * \later VM(0)[\REG{R0}] = addr(p, 0)}
                    {\textsf{Repeat v}}
                    {w, w = \textsf{Done Next 0}
                  * \VM(0)[\REG{PC}] = addr(p0, 8)
                  * \VMTOK{0}
                  * VM(0)[\REG{R0}] = addr(p, 0)
                  * VM(0)[\REG{R1}] = 42}$}
\LeftLabel{\scriptsize(Bind?)}               
\BinaryInfC{$\hoareV{\later \VM(0)[\REG{PC}] = addr(p0, 0)
                  * \later \VMTOK{0}}
                    {\textsf{Repeat (ExecInstr 0)}}
                    {v, v = \textsf{Done Next 0}
                  * \VM(0)[\REG{PC}] = addr(p0, 8)
                  * \VMTOK{0}
                  * VM(0)[\REG{R0}] = addr(p, 0)
                  * VM(0)[\REG{R1}] = 42}$}
\LeftLabel{\scriptsize(Frame)}
\UnaryInfC{$\hoareV{\later \VM(0)[\REG{PC}] = addr(p0, 0)
                  * \later \VMTOK{0}
                  * \later OE_0(p)
                  * \later addr(p, 0) \mapsto -}
                    {\textsf{Repeat (ExecInstr 0)}}
                    {v, v = \textsf{Done Next 0}
                  * \VM(0)[\REG{PC}] = addr(p0, 8)
                  * \VMTOK{0}
                  * VM(0)[\REG{R0}] = addr(p, 0)
                  * VM(0)[\REG{R1}] = 42
                  * OE_0(p)
                  * addr(p, 0) \mapsto -}$}
\AxiomC{\textbf{(1)}}
\LeftLabel{\scriptsize(Bind?)}       
\BinaryInfC{$\hoareV{\later \VM(0)[\REG{PC}] = addr(p0, 0)
                  * \later \VMTOK{0}
                  * \later OE_0(p)
                  * \later addr(p, 0) \mapsto -}
                    {\textsf{Repeat (Repeat (ExecInstr 0))}}
                    {v, v = \textsf{Done Next 0}
                  * \VM(0)[\REG{PC}] = addr(p0, 12)
                  * \VMTOK{0}
                  * VM(0)[\REG{R0}] = addr(p, 0)
                  * VM(0)[\REG{R1}] = 42
                  * OE_0(p)
                  * addr(p, 0) \mapsto 42}$}
\end{prooftree}
\end{figure}

\begin{figure}[hbt!]
\begin{prooftree}
\AxiomC{\textbf{decodeInstr(instr) = str R0, R1}}
\RightLabel{\scriptsize(str)}
\UnaryInfC{$\hoareV{\later \VM(0)[\REG{PC}] = addr(p0, 8)
                  * \later \VMTOK{0}
                  * \later VM(0)[\REG{R0}] = addr(p, 0)
                  * \later VM(0)[\REG{R1}] = 42
                  * \later OE_0(p)
                  * \later addr(p, 0) \mapsto -}
                    {\textsf{Exec Instr 0}}
                    {w, w = \textsf{Done Next 0}
                  * \VM(0)[\REG{PC}] = addr(p0, 12)
                  * \VMTOK{0}
                  * VM(0)[\REG{R0}] = addr(p, 0)
                  * VM(0)[\REG{R1}] = 42
                  * addr(p, 0) \mapsto 42}$}
\RightLabel{\scriptsize(? + Csq + Frame)}                  
\UnaryInfC{$\forall v. 
            \hoareV{v = Repeat (Done Next 0)
                  * \VM(0)[\REG{PC}] = addr(p0, 8)
                  * \VMTOK{0}
                  * VM(0)[\REG{R0}] = addr(p, 0)
                  * VM(0)[\REG{R1}] = 42
                  * OE_0(p)
                  * addr(p, 0) \mapsto -}
                    {\textsf{Repeat v}}
                    {w, w = \textsf{Done Next 0}
                  * \VM(0)[\REG{PC}] = addr(p0, 12)
                  * \VMTOK{0}
                  * VM(0)[\REG{R0}] = addr(p, 0)
                  * VM(0)[\REG{R1}] = 42
                  * addr(p, 0) \mapsto 42}$}
\UnaryInfC{\textbf{(1)}}
\end{prooftree}
\caption{First three instructions}
\end{figure}

\clearpage

\begin{figure}[hbt!]
\begin{prooftree}
\AxiomC{}
\LeftLabel{\scriptsize(I really hope so)}
\UnaryInfC{$\hoareV{\later (\VM(0)[\REG{PC}] = addr(p0, 0)
                  * \VMTOK{0}
                  * OE_0(p)
                  * OE_0(t0)
                  * addr(p, 0) \mapsto -
                  * addr(t0, 0-6) \mapsto [-,-,-,-,-,-,-])}
                    {\textsf{Repeat 26 (Exec Instr 0)}}
                    {w, w = \textsf{Done Next 0}
                  * \VM(0)[\REG{PC}] = addr(p0, 104)
                  * \VMTOK{0}
                  * VM(0)[\REG{R0}] = encode\_fid(LEND)
                  * VM(0)[\REG{R1}] = 8
                  * VM(0)[\REG{R2}] = addr(tx, 5)
                  * VM(0)[\REG{R3}] = addr(p, 0)
                  * OE_0(p)
                  * OE_0(t0)
                  * addr(p, 0) \mapsto 42
                  * addr(t0, 0-6) \mapsto [0,0,0,0,1,1,addr(p, 0)])}$}
\UnaryInfC{\textbf{(1)}}
\end{prooftree}

\begin{prooftree}
\AxiomC{\textbf{validVMID(1)} \ \textbf{decodeFFA(VM(0)[R0]) = LEND} \ \textbf{?validDescriptor?} \ \textbf{?freshHandler(h1)?} \ \textbf{decodeInstr(instr) = hvc}}
\LeftLabel{\scriptsize(lend)}
\UnaryInfC{$\hoareV{\later (\VM(0)[\REG{PC}] = addr(p0, 104) 
                    * \VMTOK{0} 
                    * \VM(0)[\REG{R0}] = encode\_fid(LEND)    
                    * OE_0(p)}
					{\textsf{ExecInstr 0}}
					{v, v = \textsf{Done Next 0} 
					* \VM(0)[\REG{PC}] = addr(p0, 108)
					* \VM(0)[\REG{R0}] = encode\_fid(LEND)
					* \VMTOK{0} 
					* ON_0(p)
					* \T (0, [(h1, \text{LEND}, [(1, p)])])
					* \R (h1, [])}$}
\UnaryInfC{\textbf{(2)}}
\end{prooftree}
\end{figure}

$X = [0,0,0,0,1,1,addr(p, 0)]$
\begin{figure}[hbt!]
\begin{prooftree}
\AxiomC{\textbf{(1)}}
\AxiomC{\textbf{(2)}}
\BinaryInfC{$\hoareV{\later (\VM(0)[\REG{PC}] = addr(p0, 0)
                  * \VMTOK{0}
                  * OE_0(p)
                  * OE_0(t0)
                  * addr(p, 0) \mapsto -
                  * addr(t0, 0-6) \mapsto [-,-,-,-,-,-,-])}
                    {\textsf{Repeat 27 (Exec Instr 0)}}
                    {w, w = \textsf{Done Next 0}
                  * \VM(0)[\REG{PC}] = addr(p0, 108)
                  * \VMTOK{0}
                  * VM(0)[\REG{R0}] = encode\_fid(LEND)
                  * VM(0)[\REG{R1}] = 8
                  * VM(0)[\REG{R2}] = addr(tx, 5)
                  * VM(0)[\REG{R3}] = addr(p, 0)
                  * ON_0(p)
                  * OE_0(t0)
                  * addr(p, 0) \mapsto 42
                  * addr(t0, 0-6) \mapsto X)
                  * \T (0, [(h1, \text{LEND}, [(1, p)])])
                  * \R (h1, [])}$}
\end{prooftree}
\caption{The first hvc}
\end{figure}

Assumptions: $X = [0,0,h1,0,1,1,addr(p, 0)]$ and $encode\_fid = e$.
\begin{figure}[hbt!]
\begin{prooftree}
\AxiomC{$\hoareV{\later (\VM(0)[\REG{PC}] = addr(p0, 0)
                  * \VMTOK{0}
                  * OE_0(p)
                  * OE_0(t0)
                  * addr(p, 0) \mapsto -
                  * addr(t0, 0-6) \mapsto [-,-,-,-,-,-,-])}
                    {\textsf{Repeat 37 (Exec Instr 0)}}
                    {w, w = \textsf{Done Next 0}
                  * \VM(0)[\REG{PC}] = addr(p0, 148)
                  * \VMTOK{0}
                  * VM(0)[\REG{R0}] = e(RUN)
                  * VM(0)[\REG{R1}] = 1
                  * VM(0)[\REG{R2}] = 2
                  * VM(0)[\REG{R3}] = addr(t0, 2)
                  * VM(0)[\REG{R4}] = h1
                  * ON_0(p)
                  * OE_0(t0)
                  * addr(p, 0) \mapsto 42
                  * addr(t0, 0-6) \mapsto X)
                  * \T (0, [(h1, \text{LEND}, [(1, p)])])
                  * \R (h1, [])}$}
\UnaryInfC{\textbf{(1)}}
\end{prooftree}
\end{figure}

\begin{figure}[hbt!]
\begin{prooftree}
\AxiomC{\textbf{validVMID(1)} \ \textbf{decodeFFA(VM(0)[R0]) = RUN} \ \textbf{decodeInstr(instr) = hvc}}
\UnaryInfC{$\hoareV{\later (\VM(0)[\REG{PC}] = addr(p0, 148)
                  * \VMTOK{0}
                  * \VM(0)[\REG{R0}] = e(RUN)
                  * \VM(0)[\REG{R1}] = 1)}
                    {\textsf{Exec Instr 0}}
                    {w, w = Done Next 1
                  * \VM(0)[\REG{PC}] = addr(p0, 152)
                  * \VMTOK{1}
                  * \VM(0)[\REG{R0}] = e(RUN)
                  * \VM(0)[\REG{R1}] = 1}$}
\UnaryInfC{\textbf{(2)}}
\end{prooftree}
\end{figure}

\begin{figure}[hbt!]
\begin{prooftree}
\AxiomC{\textbf{(1)}}
\AxiomC{\textbf{(2)}}
\BinaryInfC{$\hoareV{\later (\VM(0)[\REG{PC}] = addr(p0, 0)
                  * \VMTOK{0}
                  * OE_0(p)
                  * OE_0(t0)
                  * addr(p, 0) \mapsto -
                  * addr(t0, 0-6) \mapsto [-,-,-,-,-,-,-])}
                    {\textsf{Repeat 38 (Exec Instr 0)}}
                    {w, w = \textsf{Done Next 1}
                  * \VM(0)[\REG{PC}] = addr(p0, 152)
                  * \VMTOK{1}
                  * \VM(0)[\REG{R0}] = e(RUN)
                  * VM(0)[\REG{R1}] = 1
                  * VM(0)[\REG{R2}] = 2
                  * VM(0)[\REG{R3}] = addr(t0, 2)
                  * VM(0)[\REG{R4}] = h1
                  * ON_0(p)
                  * OE_0(t0)
                  * addr(p, 0) \mapsto 42
                  * addr(t0, 0-6) \mapsto X)
                  * \T (0, [(h1, \text{LEND}, [(1, p)])])
                  * \R (h1, [])}$}
\end{prooftree}
\caption{The third hvc}
\end{figure}

\end{document}