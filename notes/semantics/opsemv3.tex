\documentclass[a4paper]{article}
\usepackage[a4paper,tmargin=0.75in,bmargin=1in,showframe=false]{geometry}
\usepackage{multicol,multirow}
\usepackage{amsmath}
\usepackage{mathpartir}
\usepackage{hyperref}
\usepackage{todonotes}
\usepackage{graphicx}
\usepackage{kpfonts}
\usepackage{array}
\usepackage{changepage}
\usepackage[T1]{fontenc}
\usepackage{placeins}

% correct positioning against ((sub)sub)sections
\let\Oldsection\section
\renewcommand{\section}{\FloatBarrier\Oldsection}
\let\Oldsubsection\subsection
\renewcommand{\subsection}{\FloatBarrier\Oldsubsection}
\let\Oldsubsubsection\subsubsection
\renewcommand{\subsubsection}{\FloatBarrier\Oldsubsubsection}

% notations
\newcommand*{\defined}{\triangleq}
\newcommand*{\maps}{\rightarrow}
\newcommand*{\derived}{::=}

% definitions
\newcommand*{\CONF}{\text{ExecConf}}
\newcommand*{\STATE}{\text{State}}
\newcommand*{\MEM}{\text{GlobalMem}}
\newcommand*{\SSS}{\text{ShareStates}}
\newcommand*{\PID}{\text{PID}}
\newcommand*{\PT}{\text{PageTable}}
\newcommand*{\AS}{\text{AccessState}}
\newcommand*{\OS}{\text{OwnershipState}}
\newcommand*{\REGS}{\text{Registers}}
\newcommand*{\ADDR}{\text{Address}}
\newcommand*{\WORD}{\text{Word}}
\newcommand*{\VMID}{\text{VMID}}
\newcommand*{\REGNAMES}{\text{RegisterName}}
\newcommand*{\MODE}{\text{ExecMode}}
\newcommand*{\DONE}{\text{DoneState}}
\newcommand*{\INSTR}{\text{Instruction}}
\newcommand*{\MB}{\text{MailBox}}

% parameters
\newcommand*{\PABITS}{\text{ADDR\_BITS}}
\newcommand*{\PPBITS}{\text{PAGE\_BITS}}
\newcommand*{\PPIDBITS}{\text{PID\_BITS}}
\newcommand*{\PAMAX}{\text{ADDR\_MAX}}
\newcommand*{\PPMAX}{\text{PAGE\_MAX}}
\newcommand*{\PPIDMAX}{\text{PID\_MAX}}
\newcommand*{\PWBITS}{\text{WORD\_BITS}}
\newcommand*{\PWMAX}{\text{WORD\_MAX}}
\newcommand*{\PVMMAX}{\text{VM\_MAX}}


% instructions
\newcommand*{\instrm}[1]{\mathtt{#1}}
\newcommand*{\instr}[1]{\texttt{#1}}

% expressions
\newcommand*{\EI}[1]{\mathtt{ExecInstr}}
\newcommand*{\RP}[1]{{#1}}
\newcommand*{\DN}[1]{{#1}}
\newcommand*{\NXT}[1]{\mathtt{ExecInstr}}

% functions
\newcommand*{\decode}{\text{decode}}
\newcommand*{\pid}{\text{pid}}
\newcommand*{\addr}{\text{addr}}

% SOME/NONE
\newcommand{\SOME}{\mathtt{Some}}
\newcommand{\NONE}{\mathtt{None}}

% TRUE/FALSE
\newcommand{\TRUE}{\mathtt{True}}
\newcommand{\FALSE}{\mathtt{False}}

\title{Operational Semantics V3} \date{\today}
\author{Zongyuan Liu}

\begin{document}
%\maketitle

\tableofcontents

\section{VM definitions}

\begin{figure}[!htb]
  \begin{align*}
    \phi &\in \CONF &\defined &\text{States}\times \VMID \times \MEM \times \SSS \\
    \delta s &\in \text{States} &\defined &\text{list(States)} \\
    \delta &\in \STATE &\defined &\PT \times \REGS \times \MB \\
    pt & \in \PT & \defined & \PID \maps \OS \times \PID \maps \AS \\
    mb & \in \MB &\defined &\text{TXPage} \times  \text{RXPage}\\
    tx & \in \text{TXPage} &\defined &\PID\\
    rx & \in \text{RXPage} &\defined &\PID \times \text{option} ( \WORD \times \VMID ) \\
    pid & \in \PID &\defined  &[ 0, \PPIDMAX ] \\
    rs & \in \REGS &\defined  &\REGNAMES \maps \WORD \\
    rn & \in \REGNAMES &\defined &\text{SysRegs} \cup \text{GenRegs} \\
    mm & \in \MEM &\defined  &\ADDR \maps \WORD \\
    a & \in \ADDR &\defined  &[ 0, \PAMAX ] \\
    w & \in \WORD &\defined  &[ 0, \PWMAX ] \\
    sss & \in \SSS &\defined  &\WORD \maps \text{ShareState} \\
    ss & \in \text{ShareState} &\defined &\VMID \times \WORD \times \WORD \times \VMID \times \text{list}(\PID) \times \text{FunctionID}\\
    v,n & \in \VMID &\defined  &[ 0, \PVMMAX ] \\
      & \;\;\;\; \OS & \derived & O | !O \\
      & \;\;\;\; \AS & \derived & NA | EA | SA \\
      & \;\;\;\; \text{SysRegs} &\derived & \mathtt{pc} | \mathtt{NV} \\
         & \;\;\;\; \text{GenRegs} &\derived &  \mathtt {R0} | \mathtt{R1} | \dots
  \end{align*}
  \caption{Execution Configuration: VM States, Global Memory, and Share States.}
\end{figure}

\begin{figure}[!htb]
  \begin{align*}
    \mu &\in \MODE &\derived & \mathtt{ExecInstr} ~|~ \mathtt{Halt} ~|~ \mathtt{Fail}\\
    \\
    instr & \in  \INSTR &\derived & \instrm{br} \; r |\instrm{bne} \; r \; r |
                                    \instrm{mov} \; r \; w | \instrm{ldr} \; r\; r|
                                    \instrm{str} \; r \; r | \instrm{add} \; r \; r \; r |
                                    \instrm{sub} \; r \; r \; r | \instrm{cmp} \; r \; r \\
        & & & | \instrm{fail} | \instrm{halt} | \instrm{hvc}\\
    fid & \in \text{FunctionID} &\derived & \tt{RUN} ~|~\tt{YIELD} ~|~\tt{MSG\_WAIT} ~|~\tt{MSG\_SEND}
                                            ~|~\tt{MSG\_POLL}~|~\tt{MEM\_DONATE}\\
    &&&|~\tt{MEM\_RETRIEVE\_REQ} ~|~ \tt{SUCC} ~|~\tt{ERROR}~|~\tt{MEM\_RETRIEVE\_RESP}\\
    &&&|~\tt{MEM\_SHARE} ~|~ \tt{MEM\_LEND} ~|~\tt{MEM\_RECLAIM}~|~\tt{MEM\_RELINQUISH}\\
    err & \in \text{ErrorCode} &\derived & \tt{INV\_PARA} ~|~\tt{DENIED} ~|~\tt{BUSY}~|~\tt{RETRY}
  \end{align*}
  \caption{Syntax and Machine Instructions}
\end{figure}


\begin{figure}[!htb]
  \begin{mathpar}
    \inferrule[PrimStep] {} {(\EI{},\, \phi) \rightarrow (\mu ,\, \phi')}
    \and \inferrule[Step]{\phi.v=v\\(\mu_{v},\, \phi)
      \rightarrow (\mu'_{v} ,\, \phi')}
        {([\mu_0; ... ;\mu_{v}; ...;\mu_{max} ],\, \phi)
      \rightarrow ([\mu_0; ... ;\mu_{v}'; ...;\mu_{max} ] ,\, \phi')}
  \end{mathpar}
  \caption{Reduction Steps.}
\end{figure}

\newcommand{\reg}[1]{\texttt{{#1}}}
\newcommand{\ta}[1]{\text{to\_addr}({#1})}
\newcommand{\tw}[1]{\text{to\_word}({#1})}
\newcommand{\tv}[1]{\text{to\_vmid}({#1})}
\newcommand{\DNNXT}[1]{\DN{\NXT{ {#1} }}}
\begin{figure}[!htb]
    \begin{align*}
      \delta_v&=\delta s[v] & \text{state of vm with id }v.\\
      a_i&=\delta_v.rs[\mathtt{pc}] & \text{address of instruction}. \\
      rs_v&=\delta_v.rs & \text{registers of vm }v.\\
      pt_{v}&=\delta_v.pt & \text{pagetable of vm }v.\\
      pid[o] &=\text{addr}(pid,o) & \text{address at offset }o \text{ in page }pid.
    \end{align*}
    \\
    \begin{align*}
          % \text{comb}(w_{1},w_{2})&=w_{1}<<(\PWBITS/2)+w_{2}\\
    \text{addr}(p,o)&=p<<(\PPBITS/2)+o \\
    \pid(a) &= a >> \PPBITS
      \end{align*}
    \\
    \begin{align*}
      \text{AccessibleAddr}(\delta,a_i) &\defined \delta.pt[\pid(a_i)]\ne(-,NA) \\
      \text{ReadableAddr}(\delta,a_i) &\defined \delta.pt[\pid(a_i)]\ne(-,NA) \lor \delta.mb.rx=(\pid(a_i),-,-,-) \\
      \text{WritableAddr}(\delta,a_i) &\defined \delta.pt[\pid(a_i)]\ne(-,NA) \lor \delta.mb.tx=\pid(a_i) \\
      \text{DecodeInstr}(w_i,instr) &\defined \decode(w_i)=\SOME(instr)\\
      \text{OwnedExclPage}(\delta,p) & \defined \delta.pt[p]=(O,EA)\\
      \text{IsFFA}(\delta, fid) & \defined \text{decode\_fid}(\delta.rs[\reg{R0}])=\SOME(fid)\\
      \text{ValidVMID}(\delta s,n) &\defined n<\text{len}(\delta s)
    \end{align*}

    \begin{align*}
  \text{ValidDescriptor}(p,w_l,v_s,w_f,w_h,w_t,w_c,pgs,mm,\delta s,f)\defined &~~//pgs \in \VMID \mapsto \text{list}(\PID)\\
  v_{s}=\tv{mm[p[0]]} \land w_{f}=mm[p[1]] \land w_{h}=mm[p[2]] \land &~~//\text{main fields}\\
   w_{t} = mm[p[3]] \land w_{c} = mm[p[4]] \land &~~ \\
      w_l \le \PPMAX \land w_{l} = 5+3*w_{c} + \Sigma_{(\_,v)\in pgs} \text{len}(v) \land w_{c}>0 \land &~~//\text{validate length} \\
       \text{len}(pgs)=w_{c} \land (f={\tt{MEM\_DONATE}} \rightarrow w_{c}=1) \land&\\
      w_f[63:1] = 0 \land (f={\tt{MEM\_SHARE}} \rightarrow w_{f}[0]=0)\land&~~\text{validate flag}\\
  \forall i. i < w_{c}\rightarrow \big(v_{r}^{i}=\tv{mm[p[5+2*i]]} \land w_{o}^{i} = mm[p[5+2*i+1]] \land &~~//\text{get all receivers $v_{r}^{i}$ and offsets to pids $w_{o}^{i}$ }\\
  w_{n}^{i}=mm[p[5+w_{o}^{i}]] \land (\forall j. j < w_{n}^{i}\rightarrow \text{pid}(mm[p[5+w_{o}^{i}+1+j]])\in pgs[v_{r}^{i}]) \land&~~//\text{all pids are in $pgs$}\\
      \text{len}(pgs[v_{r}^{i}])=w_{n}^{i}\land v_{r}^{i}\ne v_{s} \land \text{ValidVMID}(\delta s,v_{r}^{i})\big) &~~//\text{receivers are valid}\\
      \\
  \text{ValidTransactionDescriptor}(pid_t,w_l,v_{s},w_f,w_{h},_,w_c,pgs,mm,\delta s,f) \defined & \\
  \text{ValidDescriptor}(p,w_l,v_s,w_f,w_h,w_t,w_c,pgs,mm,\delta s,f)  \land& \\
      \forall pid. \exists (v_{r}). pid \in pgs[v_{r}] \rightarrow \text{OwnedExclPage}(\delta_v, pid))\\
      \\
      \text{ValidRetrieveDescriptor}(p,w_l,v_s,w_f,w_h,w_t,v_{r},mm,sss)\defined &~~\\
  v_{s}=\tv{mm[p[0]]} \land w_{f}=mm[p[1]] \land w_{h}=mm[p[2]] \land &~~//\text{main fields}\\
      w_{t} = mm[p[3]] \land w_{c}=mm[p[4]] \land &\\
      v_{r} = \tv{mm[p[4+1]]}\land w_{o} = mm[p[4+2]]\land w_{c}= 1 \land w_{o}=0\land &~~\text{//only one receiver} \\
      w_l \le \PPMAX \land w_{l} = 7 \land  &~~//\text{validate length}\\
      w_h \in \text{dom}(sss)\land w_f[63:1]=0 \land  &~~//\text{validate handle and flag}\\
      \exists f. (v_s,\_, \_,\_, \_,f)=sss[w_h]\land (f={\tt{MEM\_SHARE}} \rightarrow w_{f}=0)
  \end{align*}
  \end{figure}

\section{Assembly instructions}

\begin{figure}[hbt!]
  \begin{mathpar}
    \inferrule[Fail-UnaccessibleInstr]
    {!\text{AccessibleAddr}(\delta_v,a_i)}
    {(\EI{v} ,\, \Phi) \rightarrow (\DN{\tt{Fail}} ,\, \Phi)}

     \inferrule[Fail-DecodingFails]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{decode}(\Phi.mm[a_i])=\NONE}
    {(\EI{v} ,\, \Phi) \rightarrow (\DN{\tt{Fail}} ,\, \Phi)}

    \inferrule[Exec-fail]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(\Phi.mm[a_i],\mathtt{fail})}
    {(\EI{v} ,\, \Phi) \rightarrow (\DN{\tt{Fail}} ,\, \Phi)}

    \inferrule[Exec-halt]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(\Phi.mm[a_i],\mathtt{halt})}
    {(\EI{v} ,\, \Phi) \rightarrow (\DN{\tt{Halt}} ,\, \Phi)}

    \inferrule[Exec-br-Succ]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{br}~rn) \\ rn\in \text{GenRegs}}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow (\EI{v} ,\, (\delta s \text{ with }\{ [v].rs[\reg{pc}]=rs_v[rn]\},mm,sss))}

    \and \inferrule[Exec-br-Fail]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{br}~rn) \\ rn\notin \text{GenRegs}}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow (\DN{\tt{Fail}} ,\, (\delta s,mm,sss))}

    \inferrule[Exec-bne-Succ-Equal]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{bne}~rn) \\ rn\in \text{GenRegs} \\ rs_v[\mathtt{NZ}]=1}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow (\DNNXT{v} ,\, (\delta s \text{ with }\{ [v].rs[\reg{pc}]=rs_v[pc]+1\},mm,sss))}

    \and \inferrule[Exec-bne-Succ-NotEqual]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{bne}~rn) \\ rn\in \text{GenRegs} \\ rs_v[\mathtt{NZ}]\ne 1}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow (\DNNXT{v} ,\, (\delta s \text{ with }\{ [v].rs[\reg{pc}]=rs_v[rn]\},mm,sss))}

    \and \inferrule[Exec-bne-Fail-InvalidInstr]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{bne}~rn) \\ rn\notin \text{GenRegs}}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow (\DN{\tt{Fail}} ,\, (\delta s,mm,sss))}

    \inferrule[Exec-mov-Succ]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{mov}~rn~w) \\ rn\in \text{GenRegs}}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow (\DNNXT{v} ,\, (\delta s \text{ with }\{ [v].rs[rn]=w ; [v].rs[\reg{pc}]=rs_v[\reg{pc}]+1\},mm,sss))}

    \and \inferrule[Exec-mov-Fail-InvalidInstr]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{mov}~rn~w) \\ rn\notin \text{GenRegs}}
    {(\DNNXT{v} ,\,(\delta s,mm,sss)) \rightarrow(\DN{\tt{Fail}} ,\, (\delta s ,mm,sss))}

    \inferrule[Exec-ldr-Succ]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{ldr}~rn_1~rn_2) \\ rn_1, rn_2\in \text{GenRegs} \\ \text{ReadableAddr}(\delta_v,\ta{rs_v[rn_2]})}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow \\ (\DNNXT{v} ,\, (\delta s \text{ with }\{rs_v[\reg{pc}]=rs_v[\reg{pc}]+1 ; rs_v[rn_1]=mm[\ta{rs_v[rn_2]}]\},mm,sss))}

    \and \inferrule[Exec-ldr-Fail-InvalidInstr]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{ldr}~rn_1~rn_2) \\ rn_1~|~rn_2\notin \text{GenRegs}}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow (\DN{\tt{Fail}} ,\, (\delta s ,mm,sss))}

    \and \inferrule[Exec-ldr-Fail-Unreadable]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{ldr}~rn_1~rn_2) \\ rn_1, rn_2\in \text{GenRegs} \\ !\text{ReadableAddr}(\delta_v,\ta{rs_v[rn_2]})}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow (\DN{\tt{Fail}} ,\, (\delta s ,mm,sss))}

  \end{mathpar}
\end{figure}


\begin{figure}
  \begin{mathpar}
    \inferrule[Exec-str-Succ]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{str}~rn_1~rn_2) \\ rn_1, rn_2\in \text{GenRegs} \\a_s=\ta{rs_v[rn_1]}\\ \text{WritableAddr}(\delta_v,a_s)}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow \\ (\DNNXT{v} ,\, (\delta s \text{ with }\{[v].rs[\reg{pc}]=rs_v[\reg{pc}]+1\},mm~\text{with}~\{[a_s]=rs_v[rn_2]\},sss))}

    \and \inferrule[Exec-str-Fail-InvalidInstr]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{str}~rn_1~rn_2) \\ rn_1~|~rn_2\notin \text{GenRegs}}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow (\DN{\tt{Fail}} ,\, (\delta s ,mm,sss))}

    \and \inferrule[Exec-str-Fail-Unwritable]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{str}~rn_1~rn_2) \\ rn_1, rn_2\in \text{GenRegs} \\a_s=\ta{rs_v[rn_1]}\\ !\text{WritableAddr}(\delta_v,a_s)}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow (\DN{\tt{Fail}} ,\, (\delta s ,mm,sss))}

    \inferrule[Exec-add-Succ]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{add}~rn_1~rn_2~rn_3) \\ rn_1, rn_2, rn_3\in \text{GenRegs} }
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow \\ (\DNNXT{v} ,\, (\delta s \text{ with }\{[v].rs[\reg{pc}] = rs_v[\reg{pc}]+1;[v].rs[rn_1]=rs_v[rn_2]+rs_v[rn_3]\},mm,sss))}

    \and \inferrule[Exec-add-Fail-InvalidInstr]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{add}~rn_1~rn_2~rn_3) \\ rn_1~|~rn_2~|~rn_3\notin \text{GenRegs}}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow (\DN{\tt{Fail}} ,\, (\delta s ,mm,sss))}

    \inferrule[Exec-sub-Succ]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{sub}~rn_1~rn_2~rn_3) \\ rn_1, rn_2, rn_3\in \text{GenRegs} }
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow \\ (\DNNXT{v} ,\, (\delta s \text{ with }\{[v].rs[\reg{pc}] = rs_v[\reg{pc}]+1;[v].rs[rn_1]=rs_v[rn_2]-rs_v[rn_3]\},mm,sss))}

    \and \inferrule[Exec-sub-Fail-InvalidInstr]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{sub}~rn_1~rn_2~rn_3) \\ rn_1~|~rn_2~|~rn_3\notin \text{GenRegs}}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow (\DN{\mathtt{Fail}} ,\, (\delta s ,mm,sss))}

     \inferrule[Exec-cmp-Succ-Zero]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{cmp}~rn_1~rn_2) \\ rn_1, rn_2\in \text{GenRegs}\\ rs_v[rn_1]-rs_v[rn_2]=0 }
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow \\ (\DNNXT{v} ,\, (\delta s \text{ with }\{[v].rs[\reg{pc}] = rs_v[\reg{pc}]+1;[v].rs[\reg{NZ}]=1\},mm,sss))}

    \and \inferrule[Exec-cmp-Succ-Neg]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{cmp}~rn_1~rn_2) \\ rn_1, rn_2\in \text{GenRegs}\\ rs_v[rn_1]-rs_v[rn_2]<0 }
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow \\ (\DNNXT{v} ,\, (\delta s \text{ with }\{[v].rs[\reg{pc}] = rs_v[\reg{pc}]+1;[v].rs[\reg{NZ}]=2\},mm,sss))}

    \and \inferrule[Exec-cmp-Succ-Pos]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{cmp}~rn_1~rn_2) \\ rn_1, rn_2\in \text{GenRegs}\\ rs_v[rn_1]-rs_v[rn_2]>0 }
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow \\ (\DNNXT{v} ,\, (\delta s \text{ with }\{[v].rs[\reg{pc}] = rs_v[\reg{pc}]+1;[v].rs[\reg{NZ}]=0\},mm,sss))}

    \and \inferrule[Exec-cmp-Fail-InvalidInstr]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{cmp}~rn_1~rn_2) \\ rn_1~|~rn_2\notin \text{GenRegs}}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow (\DN{\mathtt{Fail}} ,\, (\delta s ,mm,sss))}
  \end{mathpar}
\end{figure}

\section{FFA}

\newcommand{\efid}[1]{\text{encode\_fid}(\texttt{#1})}
\newcommand{\eec}[1]{\text{encode\_ec}(\texttt{#1})}

\subsection{Cycle management interfaces}

\begin{figure}[hbt!]
  \begin{mathpar}
    \inferrule[Exec-hvc-Succ-Run-Succ]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\\text{IsFFA}(\delta_v,\tt{RUN}) \\ n=\text{to\_vmid}(rs_v[\reg{R1}]) \\v=0\\ \text{ValidVMID}(\delta s,n)\\n\ne0\\ \delta_n.mb.rx=(-,\FALSE,-,- ) }
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow (\DNNXT{n} ,\, (\delta s \text{ with }\{[v].rs[\reg{pc}]=rs_v[\reg{pc}]+1\},mm,sss))}

    \and \inferrule[Exec-hvc-Succ-Run-MsgSend]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\\text{IsFFA}(\delta_v,\tt{RUN}) \\ n=\text{to\_vmid}(rs_v[\reg{R1}]) \\v=0\\ \text{ValidVMID}(\delta s,n)\\n\ne0\\ \delta_n.mb.rx=(-,\TRUE,w_l,v_s) }
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow (\DNNXT{n} ,\, (\delta s \text{ with}\left\{{\begin{array}{l}[v].rs[\reg{pc}]=rs_v[\reg{pc}]+1; \\ \null [n].rs[\reg{R0}]=\efid{MSG\_SEND}; \\ \null [n].rs[\reg{R1}]=\text{comb}(v_s,n);\\\null [n].rs[\reg{R3}]=w_l\end{array}}\right\},mm,sss))}

    \and \inferrule[Exec-hvc-Succ-Run-Error-Denied]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\\text{IsFFA}(\delta_v,\tt{RUN}) \\ v\ne0}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow (\DNNXT{v} ,\, (\delta s \text{ with}\left\{{\begin{array}{l}[v].rs[\reg{pc}]=rs_v[\reg{pc}]+1; \\ \null [v].rs[\reg{R0}]=\efid{ERROR}; \\ \null [v].rs[\reg{R2}]=\eec{DENIED}\end{array}}\right\},mm,sss))}

    \and \inferrule[Exec-hvc-Succ-Run-Error-InvalidParams]
    {\text{AccessibleAddr}(\delta_v,a_i)\\
    \text{DecodeInstr}(mm[a_i],\mathtt{hvc})\\
    \text{IsFFA}(\delta_v,\tt{RUN})\\
    v=0\\
    (!\text{ValidVMID}(\delta s,n) \lor n = 0)}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow (\DNNXT{v} ,\, (\delta s \text{ with}\left\{{\begin{array}{l}[v].rs[\reg{pc}]=rs_v[\reg{pc}]+1; \\ \null [v].rs[\reg{R0}]=\efid{ERROR}; \\ \null [v].rs[\reg{R2}]=\eec{INV\_PARA}\end{array}}\right\},mm,sss))}

    \and \inferrule[Exec-hvc-Succ-Yield-FromPrimary]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\\text{IsFFA}(\delta_v,\tt{YIELD}) \\v=0 }
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow \\ (\DNNXT{v} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}[v].rs[\reg{pc}]=rs_v[\reg{pc}]+1; \\\null [v].rs[\reg{R0}]=\efid{SUCC}\end{array}}\right\},mm,sss))}

    \and \inferrule[Exec-hvc-Succ-Yield-FromSecondary]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\\text{IsFFA}(\delta_v,\tt{YIELD}) \\v\ne0 }
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow (\DNNXT{0} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}[v].rs[\reg{pc}]=rs_v[\reg{pc}]+1;\\\null[0].rs[\reg{R0}]=\efid{YIELD};\\\null[0].rs[\reg{R1}]=\tw{v}\end{array}}\right\},mm,sss))}
    
  \end{mathpar}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \inferrule[Exec-hvc-Succ-MsgWait-Empty]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\\text{IsFFA}(\delta_v,\tt{MSG\_WAIT})\\ \delta_v.mb.rx=(-,\FALSE,-,-)}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow (\DNNXT{0} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}[v].rs[\reg{pc}]=rs_v[\reg{pc}]+1;\\\null[0].rs[\reg{R0}]=\efid{MSG\_WAIT};\\\null[0].rs[\reg{R1}]=\tw{v}\end{array}}\right\},mm,sss))}

    \and \inferrule[Exec-hvc-Succ-MsgWait-Ready]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\\text{IsFFA}(\delta_v,\tt{MSG\_WAIT})\\ \delta_v.mb.rx=(-,\TRUE,w_l,v_s)}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow (\DNNXT{v} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}[v].rs[\reg{pc}]=rs_v[\reg{pc}]+1;\\\null[v].rs[\reg{R0}]=\efid{MSG\_SEND};\\\null[v].rs[\reg{R1}]=\text{comb}(v_s,v);\\\null [v].rs[\reg{R3}]=w_l\end{array}}\right\},mm,sss))}
  \end{mathpar}
\end{figure}

\clearpage
    
\subsection{Messaging interfaces}

\begin{figure}[hbt!]
  \begin{mathpar}
    \inferrule[Exec-hvc-Succ-MsgSend-Succ-NotPrimary]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\\text{IsFFA}(\delta_v,\tt{MSG\_SEND})\\n = \text{to\_vmid}(rs_v[\reg{R1}])\\ \text{ValidVMID}(\delta s,n)\\w_l=rs_v[\reg{R2}]\\w_l\le\PPMAX \\ \delta_n.mb.rx=(pid_r,\FALSE,-,-)\\\delta_v.mb.tx=pid_t \\v\ne0}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow\\ (\DNNXT{0} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}[v].rs[\reg{pc}]=rs_v[\reg{pc}]+1;\\\null[v].rs[\reg{R0}]=\efid{SUCC};\\\null[n].mb.rx=(pid_r,\TRUE,w_l,v);\\\null[0].rs[\reg{R0}]=\efid{MSG\_SEND};\\\null[0].rs[\reg{R1}]=\text{comb}(v,n)\end{array}}\right\},\text{memcpy}(mm,pid_t,pid_r,w_l),sss))}

    \and \inferrule[Exec-hvc-Succ-MsgSend-Succ-Primary]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\\text{IsFFA}(\delta_v,\tt{MSG\_SEND})\\n = \text{to\_vmid}(rs_v[\reg{R1}])\\ \text{ValidVMID}(\delta s,n)\\w_l=rs_v[\reg{R2}]\\w_l\le\PPMAX \\ \delta_n.mb.rx=(pid_r,\FALSE,-,-)\\\delta_v.mb.tx=pid_t \\v=0}
    {(\EI{0} ,\,(\delta s,mm,sss)) \rightarrow\\ (\DNNXT{0} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}[0].rs[\reg{pc}]=rs_0[\reg{pc}]+1;\\\null[0].rs[\reg{R0}]=\efid{SUCC};\\\null[n].mb.rx=(pid_r,\TRUE,w_l,0)\end{array}}\right\},\text{memcpy}(mm,pid_t,pid_r,w_l),sss))}

    \and \inferrule[Exec-hvc-Succ-MsgSend-Error-Busy]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\\text{IsFFA}(\delta_v,\tt{MSG\_SEND})\\n = \text{to\_vmid}(rs_v[\reg{R1}])\\ \text{ValidVMID}(\delta s,n)\\ \delta_n.mb.rx=(-,\TRUE,-,-)}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow (\DNNXT{v} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}[v].rs[\reg{pc}]=rs_v[\reg{pc}]+1;\\\null[v].rs[\reg{R0}]=\efid{ERROR};\\\null[v].rs[\reg{R2}]=\eec{BUSY}\end{array}}\right\},mm,sss))}

    \and \inferrule[Exec-hvc-Succ-MsgSend-Error-InvalidParams]
    {\text{AccessibleAddr}(\delta_v,a_i)\\
    \text{DecodeInstr}(mm[a_i],\mathtt{hvc})\\
    \text{IsFFA}(\delta_v,\tt{MSG\_SEND})\\
    w_l=rs_v[\reg{R2}]\\
    n = \text{to\_vmid}(rs_v[\reg{R1}])\\
    (!\text{ValidVMID}(\delta s,n) \lor w_l>\PPMAX) }
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow (\DNNXT{v} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}[v].rs[\reg{pc}]=rs_v[\reg{pc}]+1;\\\null[v].rs[\reg{R0}]=\efid{ERROR};\\\null[v].rs[\reg{R2}]=\eec{INV\_PARA}\end{array}}\right\},mm,sss))}

    \and \inferrule[Exec-hvc-Succ-MsgPoll-Succ]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\\text{IsFFA}(\delta_v,\tt{MSG\_POLL})\\ \delta_v.mb.rx=(pid_r,\TRUE,w_l,v_s)}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow (\DNNXT{v} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}[v].rs[\reg{pc}]=rs_v[\reg{pc}]+1;\\\null[v].rs[\reg{R0}]=\efid{MSG\_SEND};\\\null[v].rs[\reg{R1}]=\text{comb}(v_s,n);\\\null [n].rs[\reg{R3}]=w_l;\end{array}}\right\},mm,sss))}

    \and \inferrule[Exec-hvc-Succ-MsgPoll-Error-Empty]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\\text{IsFFA}(\delta_v,\tt{MSG\_POLL})\\ \delta_v.mb.rx=(-,\FALSE,-,-)}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow (\DNNXT{v} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}[v].rs[\reg{pc}]=rs_v[\reg{pc}]+1;\\\null[v].rs[\reg{R0}]=\efid{ERROR};\\\null[v].rs[\reg{R2}]=\eec{RETRY}\end{array}}\right\},mm,sss))}

  \end{mathpar}
\end{figure}

\clearpage
\begin{figure}[hbt!]
  \begin{mathpar}
    \inferrule[Exec-hvc-Succ-RXRelease-Succ]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\\text{IsFFA}(\delta_v,\tt{RX\_RELEASE})\\ \delta_v.mb.rx=(pid_r,\TRUE,-,-)}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow\\ (\DNNXT{0} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}[v].rs[\reg{pc}]=rs_v[\reg{pc}]+1;\\\null[v].rs[\reg{R0}]=\efid{SUCC};\\\null[v].mb.rx=(pid_r,\FALSE,-,-);\end{array}}\right\},mm,sss))}

    \and \inferrule[Exec-hvc-Succ-RXRelease-Error-Denied]
    {\text{AccessibleAddr}(\delta_v,a_i) \\\text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\\text{IsFFA}(\delta_v,\tt{RX\_RELEASE})\\ \delta_v.mb.rx=(pid_r,\FALSE,-,-)}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow (\DNNXT{v} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}[v].rs[\reg{pc}]=rs_v[\reg{pc}]+1;\\\null[v].rs[\reg{R0}]=\efid{ERROR};\\\null[v].rs[\reg{R2}]=\eec{DENIED}\end{array}}\right\},mm,sss))}
      \end{mathpar}
\end{figure}
\clearpage

\subsection{Memory management interfaces}

\begin{figure}[hbt!]
  \begin{mathpar}
  
  \inferrule[Exec-hvc-Succ-MemMng-Error-InvalidParams]
  {\text{AccessibleAddr}(\delta_v,a_i)\\
  \text{DecodeInstr}(mm[a_i],\mathtt{hvc})\\
  \text{IsFFA}(\delta_v,f)\\
    f \in \{\tt{MEM\_SHARE}, \tt{MEM\_LEND}, \tt{MEM\_DONATE}\} \\
  w_l = rs_v[\reg{R1}]\\
  \pid_t = \delta_v.mb.tx\\
  !\text{ValidDescriptor}(pid_t,w_l,v_s,w_f,0,_,w_c,pgs,mm,\delta s,f)}
  {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow (\DNNXT{v} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}
  [v].rs[\reg{pc}]=rs_v[\reg{pc}]+1;\\
  \null[v].rs[\reg{R0}]=\efid{ERROR};\\
  \null[v].rs[\reg{R2}]=\eec{INV\_PARA}
  \end{array}}\right\},mm,sss))}

  \and \inferrule[Exec-hvc-Succ-MemMng-Error-Denied]
  {\text{AccessibleAddr}(\delta_v,a_i) \\
  \text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\
  \text{IsFFA}(\delta_v,f)\\
    f \in \{\tt{MEM\_SHARE}, \tt{MEM\_LEND}, \tt{MEM\_DONATE}\} \\
  w_l = rs_v[\reg{R1}]\\
  \pid_t = \delta_v.mb.tx\\
  \text{ValidDescriptor}(pid_t,w_l,v_s,w_f,0,_,w_c,pgs,mm,\delta s,f)\\
  (v\ne v_s \lor \exists pid, v_r. pid\in pgs[v_r]\land !\text{OwnedExclPage}(\delta_v,pid))}
  {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow (\DNNXT{v} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}
  [v].rs[\reg{pc}]=rs_v[\reg{pc}]+1;\\
  \null[v].rs[\reg{R0}]=\efid{ERROR};\\
  \null[v].rs[\reg{R2}]=\eec{DENIED}
  \end{array}}\right\},mm,sss))}
  
   \and \inferrule[Exec-hvc-Succ-MemMng-Succ-NotZeroed]
    {\text{AccessibleAddr}(\delta_v,a_i) \\
    \text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\
    \text{IsFFA}(\delta_v,f)\\
    f \in \{\tt{MEM\_SHARE}, \tt{MEM\_LEND}, \tt{MEM\_DONATE}\} \\
    w_l = rs_v[\reg{R1}]\\
    \pid_t = \delta_v.mb.tx\\
    \text{ValidTransactionDescriptor}(pid_t,w_l,v_s,0,0,w_t,w_c,pgs,mm,\delta s,f)\\
    w_h \notin \text{dom}(sss)\\
    w_h[63]=1}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow\\ (\DNNXT{v} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}
    [v].rs[\reg{pc}]=rs_v[\reg{pc}]+1;\\
    \null[v].rs[\reg{R0}]=\efid{SUCC};\\
    \null[v].rs[\reg{R2}]=w_h;\\
    \null \forall pid. \exists v_r. pid \in pgs[v_r] \rightarrow [v].pt[pid]=(O,NA);\\
    \null \forall pid. \exists v_r. pid \in pgs[v_r] \rightarrow [v_r].pt[pid]=(!O,NA)
    \end{array}}\right\},mm,\\ 
sss~\text{with}~\{[w_h]=(v,w_f,w_t,[],pgs,f)\})}

\and \inferrule[Exec-hvc-Succ-MemMng-Succ-Zeroed]
    {\text{AccessibleAddr}(\delta_v,a_i) \\
    \text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\
    \text{IsFFA}(\delta_v,f)\\
    f \in \{\tt{MEM\_SHARE}, \tt{MEM\_LEND}, \tt{MEM\_DONATE}\} \\
    w_l = rs_v[\reg{R1}]\\
    \pid_t = \delta_v.mb.tx\\
    \text{ValidTransactionDescriptor}(pid_t,w_l,v_s,1,0,w_t,w_c,pgs,mm,\delta s,f)\\
    w_h \notin \text{dom}(sss)\\
    w_h[63]=1}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow\\ (\DNNXT{v} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}
    [v].rs[\reg{pc}]=rs_v[\reg{pc}]+1;\\
    \null[v].rs[\reg{R0}]=\efid{SUCC};\\
    \null[v].rs[\reg{R2}]=w_h;\\
    \null \forall pid. \exists v_r. pid \in pgs[v_r] \rightarrow [v].pt[pid]=(O,NA);\\
    \null \forall pid. \exists v_r. pid \in pgs[v_r] \rightarrow [v_r].pt[pid]=(!O,NA)
    \end{array}}\right\},\text{zero}(mm,[pid| \exists v_r. pid\in pgs[v_r]]),\\
    sss~\text{with}~\{[w_h]=(v,w_f,w_t,[],pgs,f)\})}
    
    \end{mathpar}
\end{figure}



\clearpage

% \subsubsection{Lend \& Share}
% \begin{figure}[hbt!]
%   \begin{mathpar}
%       \inferrule[Exec-hvc-Succ-MemLend/Share-Error-InvalidParams]
%     {\text{AccessibleAddr}(\delta_v,a_i) \\
%     \text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\
%     \text{IsFFA}(\delta_v,f)\\
%     f \in \{\tt{MEM\_SHARE}, \tt{MEM\_LEND}\} \\
%     w_l = rs_v[\reg{R1}]\\
%     \pid_t = \delta_v.mb.tx\\
%     !\text{ValidDescriptor}(pid_t,w_l,v_s,w_f,0,_,w_c,pgs,mm,\delta s)}
%     {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow (\DNNXT{v} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}
%     [v].rs[\reg{pc}]=rs_v[\reg{pc}]+1;\\
%     \null[v].rs[\reg{R0}]=\efid{ERROR};\\
%     \null[v].rs[\reg{R2}]=\eec{INV\_PARA}
%     \end{array}}\right\},mm,sss))}

%     \and \inferrule[Exec-hvc-Succ-MemLend/Share-Error-Denied]
%     {\text{AccessibleAddr}(\delta_v,a_i) \\
%     \text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\
%     \text{IsFFA}(\delta_v,f)\\
%     f \in \{\tt{MEM\_SHARE}, \tt{MEM\_LEND}\} \\
%     w_l = rs_v[\reg{R1}]\\
%     \pid_t=\delta_v.mb.tx\\
%     \text{ValidDescriptor}(pid_t,w_l,v_s,w_f,0,_,w_c,pgs,mm,\delta s) \\
%     w_f[63:1] = 0 \\
%     (v \ne v_s \lor \exists pid, v_r. pid\in pgs[v_r] \land !\text{OwnedExclPage}(\delta_v, pid))}
%     {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow (\DNNXT{v} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}
%     [v].rs[\reg{pc}]=rs_v[\reg{pc}]+1;\\
%     \null[v].rs[\reg{R0}]=\efid{ERROR};\\
%     \null[v].rs[\reg{R2}]=\eec{DENIED}
%     \end{array}}\right\},mm,sss))}

%     \and \inferrule[Exec-hvc-Succ-MemLend/Share-Succ-NotZeroed]
%     {\text{AccessibleAddr}(\delta_v,a_i) \\
%     \text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\
%     \text{IsFFA}(\delta_v,f)\\
%     f \in \{\tt{MEM\_SHARE}, \tt{MEM\_LEND}\} \\
%     w_l = rs_v[\reg{R1}]\\
%     pid_t=\delta_v.mb.tx\\
%     \text{ValidTransactionDescriptor}(pid_t,w_l,v,0,0,w_t,w_c,pgs,mm,\delta s)\\
%     w_h \notin \text{dom}(sss) \\
%     w_h[63]=1\\
%     }
%     {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow\\ (\DNNXT{v} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}
%     [v].rs[\reg{pc}]=rs_v[\reg{pc}]+1;\\
%     \null[v].rs[\reg{R0}]=\efid{SUCC};\\
%     \null[v].rs[\reg{R2}]=w_h;\\
%     \null \forall pid. \exists v_r. pid \in pgs[v_r] \rightarrow [v].pt[pid]=(O,NA);\\
%     \null \forall pid. \exists v_r. pid \in pgs[v_r] \rightarrow [v_r].pt[pid]=(!O,NA)
%     \end{array}}\right\},mm,\\
%     sss~\text{with}~\{[w_h]=(v,0,w_t,[],pgs,f)\}))}

%     \and \inferrule[Exec-hvc-Succ-MemLend/Share-Succ-Zeroed]
%     {\text{AccessibleAddr}(\delta_v,a_i) \\
%     \text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\
%     \text{IsFFA}(\delta_v,f)\\
%     f \in \{\tt{MEM\_SHARE}, \tt{MEM\_LEND}\} \\
%     w_l = rs_v[\reg{R1}]\\
%     pid_t=\delta_v.mb.tx\\
%     \text{ValidTransactionDescriptor}(pid_t,w_l,v,1,0,w_t,w_c,pgs,mm,\delta s)\\
%     w_h \notin \text{dom}(sss) \\
%     w_h[63]=1
%     }
%     {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow\\ (\DNNXT{v} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}
%     [v].rs[\reg{pc}]=rs_v[\reg{pc}]+1;\\
%     \null[v].rs[\reg{R0}]=\efid{SUCC};\\
%     \null[v].rs[\reg{R2}]=w_h;\\
%     \null \forall pid. \exists v_r. pid \in pgs[v_r] \rightarrow [v].pt[pid]=(O,NA);\\
%     \null \forall pid. \exists v_r. pid \in pgs[v_r] \rightarrow [v_r].pt[pid]=(!O,NA)\end{array}}\right\},
%     \text{zero}(mm,[pid| \exists v_r. pid\in pgs[v_r]]),\\
%     sss~\text{with}~\{[w_h]=(v,1,w_t,[],pgs,f)\}))}

%   \end{mathpar}
% \end{figure}

% \clearpage
\subsubsection{Retrieve}
\begin{figure}[hbt!]
  \begin{mathpar}

  \inferrule[Exec-hvc-Succ-MemRetrieve-Error-InvalidParams]
    {\text{AccessibleAddr}(\delta_v,a_i) \\
    \text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\
    \text{IsFFA}(\delta_v,\tt{MEM\_RETRIEVE\_REQ})\\
    pid_t=\delta_v.mb.tx \\
    w_l = rs_v[\reg{R1}] \\
    !\text{ValidRetrieveDescriptor}(pid_t,w_l,v_s,w_f,w_h,w_t,v,mm,sss)}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow (\DNNXT{v} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}
    [v].rs[\reg{pc}]=rs_v[\reg{pc}]+1;\\
    \null[v].rs[\reg{R0}]=\efid{ERROR};\\
    \null[v].rs[\reg{R2}]=\eec{INV\_PARA}
    \end{array}}\right\},mm,sss))}

    \and \inferrule[Exec-hvc-Succ-MemRetrieve-Error-Busy]
    {\text{AccessibleAddr}(\delta_v,a_i) \\
    \text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\
    \text{IsFFA}(\delta_v,\tt{MEM\_RETRIEVE\_REQ})\\
    w_l = rs_v[\reg{R1}]\\
    \pid_t=\delta_v.mb.tx\\
    \text{ValidRetrieveDescriptor}(pid_t,w_l,v_s,w_f,w_h,w_t,v,mm,sss)\\
    \delta_v.mb.rx=(-,\TRUE,-,-) }
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow (\DNNXT{v} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}
    [v].rs[\reg{pc}]=rs_v[\reg{pc}]+1;\\
    \null[v].rs[\reg{R0}]=\efid{ERROR};\\
    \null[v].rs[\reg{R2}]=\eec{BUSY}
    \end{array}}\right\},mm,sss))}

  \end{mathpar}
\end{figure}


\begin{figure}
  \begin{mathpar}

    \inferrule[Exec-hvc-Succ-MemRetrieve-MemDonate-NotZeroed]
    {\text{AccessibleAddr}(\delta_v,a_i) \\
    \text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\
    \text{IsFFA}(\delta_v,\tt{MEM\_RETRIEVE\_REQ})\\
    w_l=rs_v[\reg{R1}]\\
    pid_t=\delta_v.mb.tx\\
    \text{ValidRetrieveDescriptor}(pid_t,w_l,v_s,0,w_h,w_t,v,mm)\\
    (v_s,w_f,w_t,vrs, pgs,\tt{MEM\_DONATE})=sss[w_h]\\
    %\text{len}(pgs)=1 \\
    (v,ps) \in pgs \\
    v\notin vrs\\
    \delta_v.mb.rx=(pid_r,\FALSE,-,-) }
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow\\
    (\DNNXT{v} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}
    [v].rs[\reg{pc}]=rs_v[\reg{pc}]+1;\\
    \null[v].rs[\reg{R0}]=\efid{MEM\_RETRIEVE\_RESP};\\
    \null[v].rs[\reg{R1}]=8+\text{len}(ps);\\
    \null \forall pid. pid\in ps \land \big(\forall v_r,ps'. v_r \ne v \land  (v_r,ps')\in pgs \rightarrow pid \notin ps'\big) \rightarrow [v].pt[pid]=(O,EA);\\
    \null \forall pid. pid\in ps \rightarrow [v_s].pt[pid]=(!O,NA);\\
    \null[v].mb.rx=(pid_r,\TRUE,8+\text{len}(ps),-)
    \end{array}}\right\},\\
    mm~\text{with}~\left\{{\begin{array}{l}
    pid_r[0]=\tw{v_s};\\
    \null pid_r[1]=w_f \& 0\text{x}18;\\
    \null pid_r[2]=0;\\
    \null pid_r[3]=w_t;\\
    \null pid_r[4]=1;\\
    \null pid_r[5]=\tw{v};\\
    \null pid_r[6]=7;\\
    \null pid_r[7]=\text{len}(ps);\\
    \null \forall i. i < \text{len}(ps) \rightarrow pid_r[8+i]=ps[i][0]
    \end{array}}\right\},\text{remove}(sss,w_h)))}

    \and \inferrule[Exec-hvc-Succ-MemRetrieve-MemDonate-Zeroed]
    {\text{AccessibleAddr}(\delta_v,a_i) \\
    \text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\
    \text{IsFFA}(\delta_v,\tt{MEM\_RETRIEVE\_REQ})\\
    w_l=rs_v[\reg{R1}]\\
    pid_t=\delta_v.mb.tx\\
    \text{ValidRetrieveDescriptor}(pid_t,w_l,v_s,1,w_h,w_t,mm)\\
    (v_s,w_f,w_t,vrs, pgs,\tt{MEM\_DONATE})=sss[w_h]\\
    %\text{len}(pgs)=1 \\
    (v,ps) \in pgs \\
    v\notin vrs\\
    \delta_v.mb.rx=(pid_r,\FALSE,-,-) }
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow\\
    (\DNNXT{v} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}
    [v].rs[\reg{pc}]=rs_v[\reg{pc}]+1;\\
    \null[v].rs[\reg{R0}]=\efid{MEM\_RETRIEVE\_RESP};\\
    \null[v].rs[\reg{R1}]=8+\text{len}(ps);\\
    \null \forall pid. pid\in ps \land \big(\forall v_r,ps'. v_r \ne v \land  (v_r,ps')\in pgs \rightarrow pid \notin ps'\big) \rightarrow [v].pt[pid]=(O,EA);\\
    \null \forall pid. pid\in ps \rightarrow [v_s].pt[pid]=(!O,NA);\\
    \null[v].mb.rx=(pid_r,\TRUE,8+\text{len}(ps),-)
    \end{array}}\right\},\\
    \text{zero}(mm,ps)~\text{with}~\left\{{\begin{array}{l}
    pid_r[0]=\tw{v_s};\\
    \null pid_r[1]=1 \& 0\text{x}18;\\
    \null pid_r[2]=0;\\
    \null pid_r[3]=w_t;\\
    \null pid_r[4]=1;\\
    \null pid_r[5]=\tw{v};\\
    \null pid_r[6]=7;\\
    \null pid_r[7]=\text{len}(ps);\\
    \null \forall i. i < \text{len}(ps) \rightarrow pid_r[8+i]=ps[i][0]
    \end{array}}\right\},\text{remove}(sss,w_h))}

  \end{mathpar}
\end{figure}

\begin{figure}
  \begin{mathpar}

    \inferrule[Exec-hvc-Succ-MemRetrieve-MemLend-NotZeroed]
    {\text{AccessibleAddr}(\delta_v,a_i) \\
    \text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\
    \text{IsFFA}(\delta_v,\tt{MEM\_RETRIEVE\_REQ})\\
    w_l=rs_v[\reg{R1}]\\
    pid_t=\delta_v.mb.tx\\
    \text{ValidRetrieveDescriptor}(pid_t,w_l,v_s,0,w_h,w_t,v,mm,sss)\\
    (v_s,w_f,w_t,vrs, pgs,\tt{MEM\_LEND})=sss[w_h]\\
    (v,ps) \in pgs \\
    v\notin vrs\\
    \delta_v.mb.rx=(pid_r,\FALSE,-,-) }
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow\\
    (\DNNXT{v} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}
    [v].rs[\reg{pc}]=rs_v[\reg{pc}]+1;\\
    \null[v].rs[\reg{R0}]=\efid{MEM\_RETRIEVE\_RESP};\\
    \null[v].rs[\reg{R2}]=8+\text{len}(ps);\\
    \null \forall pid. pid\in ps \land \big(\exists v_r,ps'. v_r \ne v \land (v_r,ps')\in pgs \rightarrow pid\in ps'\big) \rightarrow [v].pt[pid]=(!O,SA);\\
    \null \forall pid. pid\in ps \land \big(\forall v_r,ps'. v_r \ne v \land  (v_r,ps')\in pgs \rightarrow pid \notin ps'\big) \rightarrow [v].pt[pid]=(!O,EA);\\
    \null \forall pid. pid\in ps \rightarrow [v_s].pt[pid]=(O,NA);\\
    \null[v].mb.rx=(pid_r,\TRUE,8+\text{len}(ps),-)
    \end{array}}\right\},\\
    mm~\text{with}~\left\{{\begin{array}{l}
    pid_r[0]=\tw{v_s};\\
    \null pid_r[1]=w_f \& 0\text{x}10;\\
    \null pid_r[2]=0;\\
    \null pid_r[3]=w_t;\\
    \null pid_r[4]=1;\\
    \null pid_r[5]=\tw{v};\\
    \null pid_r[6]=7;\\
    \null pid_r[7]=\text{len}(ps);\\
    \null \forall i. i < \text{len}(ps) \rightarrow pid_r[8+i]=ps[i][0]
    \end{array}}\right\},sss~\text{with}\{[w_h]=(v_s,w_f,w_t,v::vrs, pgs,\tt{MEM\_LEND})\})}

    \and \inferrule[Exec-hvc-Succ-MemRetrieve-MemLend-Zeroed]
    {\text{AccessibleAddr}(\delta_v,a_i) \\
    \text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\
    \text{IsFFA}(\delta_v,\tt{MEM\_RETRIEVE\_REQ})\\
    w_l=rs_v[\reg{R1}]\\
    pid_t=\delta_v.mb.tx\\
    \text{ValidRetrieveDescriptor}(pid_t,w_l,v_s,1,w_h,w_t,v,mm,sss)\\
    (v_s,w_f,w_t,vrs, pgs,\tt{MEM\_LEND})=sss[w_h]\\
    (v,ps) \in pgs \\
    v\notin vrs
    \delta_v.mb.rx=(pid_r,\FALSE,-,-) }
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow\\
    (\DNNXT{v} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}
    [v].rs[\reg{pc}]=rs_v[\reg{pc}]+1;\\
    \null[v].rs[\reg{R0}]=\efid{MEM\_RETRIEVE\_RESP};\\
    \null[v].rs[\reg{R2}]=8+\text{len}(ps);\\
    \null \forall pid. pid\in ps \land \big(\exists v_r,ps'. v_r \ne v \land (v_r,ps')\in pgs \rightarrow pid\in ps'\big) \rightarrow [v].pt[pid]=(!O,SA);\\
    \null \forall pid. pid\in ps \land \big(\forall v_r,ps'. v_r \ne v \land  (v_r,ps')\in pgs \rightarrow pid \notin ps'\big) \rightarrow [v].pt[pid]=(!O,EA);\\
    \null \forall pid. pid\in ps \rightarrow [v_s].pt[pid]=(O,NA);\\
    \null[v].mb.rx=(pid_r,\TRUE,8+\text{len}(ps),-)
    \end{array}}\right\},\\
    \text{zero}(mm,ps)~\text{with}~\left\{{\begin{array}{l}
    pid_r[0]=\tw{v_s};\\
    \null pid_r[1]=1\&0\text{x}10;\\
    \null pid_r[2]=0;\\
    \null pid_r[3]=w_t;\\
    \null pid_r[4]=1;\\
    \null pid_r[5]=\tw{v};\\
    \null pid_r[6]=7;\\
    \null pid_r[7]=\text{len}(ps);\\
    \null \forall i. i < \text{len}(ps) \rightarrow pid_r[8+i]=ps[i][0]
    \end{array}}\right\},sss ~\text{with}\{[w_h]=(v_s,w_f,w_t,v::vrs, pgs,\tt{MEM\_LEND})\})}

  \end{mathpar}
\end{figure}

\begin{figure}
  \begin{mathpar}

     \inferrule[Exec-hvc-Succ-MemRetrieve-MemShare-NotZeroed]
    {\text{AccessibleAddr}(\delta_v,a_i) \\
    \text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\
    \text{IsFFA}(\delta_v,\tt{MEM\_RETRIEVE\_REQ})\\
    w_l=rs_v[\reg{R1}]\\
    pid_t=\delta_v.mb.tx\\
    \text{ValidRetrieveDescriptor}(pid_t,w_l,v_s,0,w_h,w_t,v,mm,sss)\\
    (v_s,w_f,w_t,vrs, pgs,\tt{MEM\_SHARE})=sss[w_h]\\
    (v,ps) \in pgs \\
    v\notin vrs\\
    \delta_v.mb.rx=(pid_r,\FALSE,-,-) }
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow\\
    (\DNNXT{v} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}
    [v].rs[\reg{pc}]=rs_v[\reg{pc}]+1;\\
    \null[v].rs[\reg{R0}]=\efid{MEM\_RETRIEVE\_RESP};\\
    \null[v].rs[\reg{R2}]=8+\text{len}(ps);\\
    \null \forall pid. pid\in ps \rightarrow [v].pt[pid]=(!O,SA);\\
    \null \forall pid. pid\in ps \rightarrow [v_s].pt[pid]=(O,SA);\\
    \null[v].mb.rx=(pid_r,\TRUE,8+\text{len}(ps),-)
    \end{array}}\right\},\\
    mm~\text{with}~\left\{{\begin{array}{l}
    pid_r[0]=\tw{v_s};\\
    \null pid_r[1]=w_f \& 0\text{x}08;\\
    \null pid_r[2]=0;\\
    \null pid_r[3]=w_t;\\
    \null pid_r[4]=1;\\
    \null pid_r[5]=\tw{v};\\
    \null pid_r[6]=7;\\
    \null pid_r[7]=\text{len}(ps);\\
    \null \forall i. i < \text{len}(ps) \rightarrow pid_r[8+i]=ps[i][0]
    \end{array}}\right\},sss~\text{with}\{[w_h]=(v_s,w_f,w_t,v::vrs, pgs,\tt{MEM\_SHARE})\})}

  \end{mathpar}
\end{figure}

\clearpage
\subsubsection{Relinquish}
  \begin{align*}
  \text{ValidRelinquishDescriptor}(p,w_l,w_h,w_f,mm)\defined &~~\\
  w_{h}=mm[p[0]] \land w_{f}=mm[p[1]] &~~//\text{main fields}
  \end{align*}
\begin{figure}[hbt!]
  \begin{mathpar}
  
    \inferrule[Exec-hvc-MemRelinquish-Error-InvalidParams]
    {\text{AccessibleAddr}(\delta_v,a_i)\\
    \text{DecodeInstr}(mm[a_i],\mathtt{hvc})\\
    \text{IsFFA}(\delta_v,\tt{MEM\_RELINQUISH})\\
    \pid_t=\delta_v.mb.tx\\ 
    !\text{ValidRelinquishDescriptor}(pid_t,w_h,w_f,mm)\lor w_h \notin \text{dom}(sss)}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow\\ 
    (\DNNXT{v} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}
    [v].rs[\reg{pc}]=rs_v[\reg{pc}]+1;\\
    \null[v].rs[\reg{R0}]=\efid{ERROR};\\
    \null[v].rs[\reg{R2}]=\eec{INV\_PARA};\\
    \end{array}}\right\},\\
    mm, sss)}
    
    \and \inferrule[Exec-hvc-MemRelinquish-Error-Denied]
    {\text{AccessibleAddr}(\delta_v,a_i)\\
    \text{DecodeInstr}(mm[a_i],\mathtt{hvc})\\
    \text{IsFFA}(\delta_v,\tt{MEM\_RELINQUISH})\\
    \pid_t=\delta_v.mb.tx\\ 
    \text{ValidRelinquishDescriptor}(pid_t,w_h,w_f,mm)\\
    w_h \in \text{dom}(sss)\\
    (v_s,w_f,w_t,vrs, pgs,f)=sss[w_h] \\
    v \notin vrs \lor (\exists pid. pid\in pgs[v] \rightarrow pt_v[pid] \notin \{(!O, EA),(!O,SA)\})}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow\\ 
    (\DNNXT{v} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}
    [v].rs[\reg{pc}]=rs_v[\reg{pc}]+1;\\
    \null[v].rs[\reg{R0}]=\efid{ERROR};\\
    \null[v].rs[\reg{R2}]=\eec{DENIED};\\
    \end{array}}\right\},\\
    mm, sss)}
  
    \and \inferrule[Exec-hvc-MemRelinquish-Succ-NotZeroed]
    {\text{AccessibleAddr}(\delta_v,a_i) \\
    \text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\
    \text{IsFFA}(\delta_v,\tt{MEM\_RELINQUISH})\\
    pid_t=\delta_v.mb.tx\\ 
    \text{ValidRelinquishDescriptor}(pid_t,w_h,0,mm)\\
    w_h \in \text{dom}(sss)\\
    (v_s,w_f,w_t,vrs, pgs,f)=sss[w_h] \\
    v \in vrs \\
    \forall pid. pid\in pgs[v] \rightarrow pt_v[pid] \in \{(!O, EA),(!O,SA)\}}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow\\ 
    (\DNNXT{v} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}
    [v].rs[\reg{pc}]=rs_v[\reg{pc}]+1;\\
    \null[v].rs[\reg{R0}]=\efid{SUCC};\\
    \null \forall pid. pid\in pgs[v] \rightarrow [v].pt[pid]=(!O,NA);\\
    \end{array}}\right\},\\
    mm, sss~\text{with}\{ [w_h] = (v_s,w_f,w_t,vrs\backslash \{v\}, pgs,f)\})}


    \and \inferrule[Exec-hvc-MemRelinquish-Succ-Zeroed]
    {\text{AccessibleAddr}(\delta_v,a_i) \\
    \text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\
    \text{IsFFA}(\delta_v,\tt{MEM\_RELINQUISH})\\
    pid_t=\delta_v.mb.tx\\
    \text{ValidRelinquishDescriptor}(pid_t,w_h,1,mm)\\
    w_h \in \text{dom}(sss)\\
    (v_s,w_f,w_t,vrs, pgs,f)=sss[w_h] \\
    v \in vrs \\
    \forall pid. pid\in pgs[v] \rightarrow pt_v[pid] \in \{(!O, EA),(!O,SA)\}}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow\\
    (\DNNXT{v} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}
    [v].rs[\reg{pc}]=rs_v[\reg{pc}]+1;\\
    \null[v].rs[\reg{R0}]=\efid{SUCC};\\
    \null \forall pid. pid\in pgs[v] \rightarrow [v].pt[pid]=(!O,NA);\\
    \end{array}}\right\},\\
    \text{zero}(mm,pgs[v]), sss~\text{with}\{ [w_h] = (v_s,w_f,w_t,vrs\backslash \{v\}, pgs,f)\})}
  
  \end{mathpar}
\end{figure}

\clearpage

\subsubsection{Reclaim}

\begin{figure}[hbt!]
  \begin{mathpar}
  
    \inferrule[Exec-hvc-Reclaim-Error-InvalidParams]
    {\text{AccessibleAddr}(\delta_v,a_i) \\
    \text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\
    \text{IsFFA}(\delta_v,\tt{MEM\_RECLAIM})\\
    w_h=comb(rs_v[\reg{R1}], rs_v[\reg{R2}])\\
    w_f=rs_v[\reg{R3}]\\
    w_h \not \in \text{dom}(sss) \lor w_f[63:1] \ne 0}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow\\ 
    (\DNNXT{v} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}
    [v].rs[\reg{pc}]=rs_v[\reg{pc}]+1;\\
    \null[v].rs[\reg{R0}]=\efid{ERROR};\\
    \null[v].rs[\reg{R2}]=\eec{INV\_PARA};
    \end{array}}\right\},
    mm, sss)}
    
    \inferrule[Exec-hvc-Reclaim-Error-Denied]
    {\text{AccessibleAddr}(\delta_v,a_i) \\
    \text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\
    \text{IsFFA}(\delta_v,\tt{MEM\_RECLAIM})\\
    w_h=comb(rs_v[\reg{R1}], rs_v[\reg{R2}])\\
    w_f=rs_v[\reg{R3}]\\
    w_h \in \text{dom}(sss)\\
    w_f[63:1] = 0\\
    (v_s,w_f,w_t,vrs, pgs,f)=sss[w_h]\\
    %\big(\exists pid, v_r. pid \in pgs[v_r] \rightarrow pt_{v_r}[pid] \ne (!O, NA)\big) \lor
    vrs \ne []}
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow\\ 
    (\DNNXT{v} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}
    [v].rs[\reg{pc}]=rs_v[\reg{pc}]+1;\\
    \null[v].rs[\reg{R0}]=\efid{ERROR};\\
    \null[v].rs[\reg{R2}]=\eec{DENIED};
    \end{array}}\right\},
    mm, sss)}
  
    \and \inferrule[Exec-hvc-Succ-MemReclaim-NotZeroed]
    {\text{AccessibleAddr}(\delta_v,a_i) \\
    \text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\
    \text{IsFFA}(\delta_v,\tt{MEM\_RECLAIM})\\
    w_h=comb(rs_v[\reg{R1}], rs_v[\reg{R2}])\\
    w_f=rs_v[\reg{R3}]\\
    w_h \in \text{dom}(sss) \\
    w_f = 0\\
    (v_s,w_f,w_t,vrs, pgs,f)=sss[w_h]\\
    % \big(\forall pid. \exists v_r. pid \in pgs[v_r] \rightarrow pt_{v_r}[pid] = (!O, NA)\big)\\
    % perhaps vrs = [] is enough?
    vrs = []
   }
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow\\ 
    (\DNNXT{v} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}
    [v].rs[\reg{pc}]=rs_v[\reg{pc}]+1;\\
    \null[v].rs[\reg{R0}]=\efid{SUCC};\\
    \null \forall pid. \exists v_r. pid\in pgs[v_r] \rightarrow [v].pt[pid]=(O,EA);\\
    \end{array}}\right\},\\
    mm, \text{remove}(sss, w_h))}
    
    \and \inferrule[Exec-hvc-Succ-MemReclaim-Zeroed]
    {\text{AccessibleAddr}(\delta_v,a_i) \\
    \text{DecodeInstr}(mm[a_i],\mathtt{hvc}) \\
    \text{IsFFA}(\delta_v,\tt{MEM\_RECLAIM})\\
    w_h=comb(rs_v[\reg{R1}], rs_v[\reg{R2}])\\
    w_f=rs_v[\reg{R3}]\\
    w_h \in \text{dom}(sss) \\
    w_f = 1\\
    (v_s,w_f,w_t,vrs, pgs,f)=sss[w_h]\\
    % \big(\forall pid. \exists v_r. pid \in pgs[v_r] \rightarrow pt_{v_r}[pid] = (!O, NA)\big)\\
    % perhaps vrs = [] is enough?
    vrs = []
   }
    {(\EI{v} ,\,(\delta s,mm,sss)) \rightarrow\\
    (\DNNXT{v} ,\, (\delta s \text{ with }\left\{{\begin{array}{l}
    [v].rs[\reg{pc}]=rs_v[\reg{pc}]+1;\\
    \null[v].rs[\reg{R0}]=\efid{SUCC};\\
    \null \forall pid. \exists v_r. pid\in pgs[v_r] \rightarrow [v].pt[pid]=(O,EA);\\
    \end{array}}\right\},\\
    \text{zero}(mm,[pid|\exists v_r. pid\in pgs[v_r]]), \text{remove}(sss, w_h))}

  \end{mathpar}
\end{figure}


\end{document}
